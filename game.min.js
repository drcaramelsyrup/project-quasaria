(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.app = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * `app` module
 * ============
 *
 * Provides the game initialization routine.
 */

'use strict';

// Import game states.
var states = require('./states');

exports.init = function () {
  var game = new Phaser.Game(800, 600, Phaser.AUTO);

  // Dynamically add all required game states.
  Object
    .keys(states)
    .forEach(function (key) {
      game.state.add(key, states[key]);
    });

  game.state.start('Boot');

  return game;
};

},{"./states":29}],2:[function(require,module,exports){
/*
 * `assets` module
 * ===============
 *
 * Declares static asset packs to be loaded using the `Phaser.Loader#pack`
 * method. Use this module to declare game assets.
 */

'use strict';

// -- Splash screen assets used by the Preloader.
exports.boot = [{
  key: 'splash-screen',
  type: 'image'
}, {
  key: 'progress-bar',
  type: 'image'
}];

exports.main_menu = [{
  key: 'quasaria-logo-MM',
  type: 'image'
}, {
  key: 'continueButton',
  type: 'image'
}, {
  key: 'menu_screen',
  type: 'image',
  url: 'backgrounds/menu_screen_scaled.png'
}];


// -- General assets used throughout the game.
exports.game = [{
  key: 'quasaria-logo',
  type: 'image'
}, {
  key: 'shuttle',
  type: 'image',
  url: 'backgrounds/shuttle.png'
}, {
  key: 'hangar',
  type: 'image',
  url: 'backgrounds/hangar.png'
}, {
  key: 'medbay',
  type: 'image',
  url: 'backgrounds/medbay.png'
}, {
  key: 'listener',
  type: 'image',
  url: 'items/listener.png'
}, {
  key: 'note',
  type: 'image',
  url: 'items/note.png'
}, {
  key: 'biologistApproval',
  type: 'image',
  url: 'avatars/talvine.png'
}, {
  key: 'psychologistApproval',
  type: 'image',
  url: 'avatars/valken.png'
}, {
  key: 'shuttle-placeable',
  type: 'image',
  url: 'items/shuttle-placeable.png'
}, {
  key: 'vesper-npc',
  type: 'image',
  url: 'npcs/vesper.png'
}, {
  key: 'talvine-npc',
  type: 'image',
  url: 'npcs/talvine.png'
}, {
  key: 'valken-npc',
  type: 'image',
  url: 'npcs/valken.png'
}, {
  key: 'gleaming-shoal-npc',
  type: 'image',
  url: 'npcs/gleaming-shoal.png'
}];

// -- UI-specific assets.
exports.ui = [{
  key: 'dialogue-choice-button',
  type: 'image',
  url: 'ui/dialogue-choice-button.png'
}, {
  key: 'dialogue-panel',
  type: 'image',
  url: 'ui/dialogue-panel.png'
}, {
  key: 'toast',
  type: 'image',
  url: 'ui/toast.png'
}, {
  key: 'memory-bank-button',
  type: 'image',
  url: 'ui/memory-bank-button.png'
}, {
  key: 'memory-bank-icon',
  type: 'image',
  url: 'ui/memory-bank-icon.png'
}, {
  key: 'memory-bank-icon-mask',
  type: 'image',
  url: 'ui/memory-bank-icon-mask.png'
}, {
  key: 'memory-bank-next',
  type: 'image',
  url: 'ui/memory-bank-next.png'
}, {
  key: 'memory-bank',
  type: 'image',
  url: 'ui/memory-bank.png'
}, {
  key: 'saveButton',
  type: 'image'
}, {
  key: 'button',
  type: 'image',
  url: 'ui/button.png'
}, {
  key: 'battle-background',
  type: 'image',
  url: 'ui/battle-background.png'
}, {
  key: 'battle-overlay',
  type: 'image',
  url: 'ui/battle-overlay-scaled.png'
}, {
  key: 'memory-bank-icon-fill',
  type: 'image',
  url: 'ui/memory-bank-icon-fill.png'
}, {
  key: 'companion-icon',
  type: 'image',
  url: 'ui/companion-icon.png'
}, {
  key: 'enemy-arg-icon',
  type: 'image',
  url: 'ui/enemy-arg-icon.png'
}];

// -- Conversation jsons and avatars.
exports.conversations = [{
  key: 'prologue01',
  type: 'json',
  url: 'conversations/prologue01.json'
}, {
  key: 'prologue02',
  type: 'json',
  url: 'conversations/prologue02.json'
}, {
  key: 'vesper01',
  type: 'json',
  url: 'conversations/vesper01.json'
}, {
  key: 'talvine01',
  type: 'json',
  url: 'conversations/talvine01.json'
}, {
  key: 'valken01',
  type: 'json',
  url: 'conversations/valken01.json'
}, {
  key: 'gleaming-shoal01',
  type: 'json',
  url: 'conversations/gleaming-shoal01.json'
}, {
  key: 'mysterious-voice',
  type: 'image',
  url: 'avatars/mysterious-voice.png'
}, {
  key: 'kismet',
  type: 'image',
  url: 'avatars/kismet.png'
}, {
  key: 'gleaming-shoal',
  type: 'image',
  url: 'avatars/gleaming-shoal.png'
}, {
  key: 'gleaming-shoal-portrait',
  type: 'image',
  url: 'avatars/gleaming-shoal-portrait.png'
}, {
  key: 'unknown-alien',
  type: 'image',
  url: 'avatars/gleaming-shoal-silhouette.png'
}, {
  key: 'vesper',
  type: 'image',
  url: 'avatars/vesper.png'
}, {
  key: 'talvine',
  type: 'image',
  url: 'avatars/talvine.png'
}, {
  key: 'valken',
  type: 'image',
  url: 'avatars/valken.png'
}, {
  key: 'invisible',
  type: 'image',
  url: 'avatars/invisible.png'
}];

// -- Sound effects and background music
exports.sounds = [{
  key: 'sunrise-from-orbit',
  type: 'audio',
  urls: ['music/Sunrise From Orbit (Demo).mp3']
}, {
  key: 'menu-theme-terraform',
  type: 'audio',
  urls: ['music/Terraforming-Begins_Looping.mp3']
}, {
  key: 'off-limits',
  type: 'audio',
  urls: ['music/Sector-Off-Limits_Looping.mp3']
}, {
  key: 'puzzle1',
  type: 'audio',
  urls: ['music/Puzzle-Game_Looping.mp3']
}, {
  key: 'puzzle2',
  type: 'audio',
  urls: ['music/Puzzle-Game-2_Looping.mp3']
}, {
  key: 'lostjungle',
  type: 'audio',
  urls: ['music/Lost-Jungle_Looping.mp3']
}, {
  key: 'cold-moon',
  type: 'audio',
  urls: ['music/Cold-Moon.mp3']
}, {
  key: 'correct-card',
  type: 'audio',
  urls: ['soundfx/positive/glow_med_L_to_R_002.wav']
}, {
  key: 'wrong-card',
  type: 'audio',
  urls: ['soundfx/negative/SW011_Alarms_construction-kit-element_081.wav']
}, {
  key: 'save-notification',
  type: 'audio',
  urls: ['soundfx/SFX-ARCADIA_Notification01.wav']
}, {
  key: 'swish-close',
  type: 'audio',
  urls: ['soundfx/13th-whoosh-swing-sound.mp3']
}, {
  key: 'swish-open',
  type: 'audio',
  urls: ['soundfx/swoosh-metal-rod-swing-sound-made-with-bamboo-stick.mp3']
}, {
  key: 'inventory-add',
  type: 'audio',
  urls: ['soundfx/SFX-ARCADIA_Error03.wav']
}];

// --logic battle placeholder images

exports.logic_battle = [{
  key: 'alien-stare',
  type: 'image',
  url: 'battle/alien-stare.png'
}, {
  key: 'greek-sphinx',
  type: 'image',
  url: 'battle/greek-sphinx.png'
}, {
  key: 'cyborg-face',
  type: 'image',
  url: 'battle/cyborg-face.png'
}, {
  key: 'curly-mask',
  type: 'image',
  url: 'battle/curly-mask.png'
}, {
  key: 'lunar-module',
  type: 'image',
  url: 'battle/lunar-module.png'
}, {
  key: 'fencer',
  type: 'image',
  url: 'battle/fencer.png'
}, {
  key: 'new-born',
  type: 'image',
  url: 'battle/new-born.png'
}, {
  key: 'saint-basil-cathedral',
  type: 'image',
  url: 'battle/saint-basil-cathedral.png'
}, {
  key: 'goblin-head',
  type: 'image',
  url: 'battle/goblin-head.png'
}, {
  key: 'xenobio',
  type: 'image',
  url: 'battle/xenobio.png'
}, {
  key: 'xenopsych',
  type: 'image',
  url: 'battle/xenopsych.png'
}, {
  key: 'quasaria-logo-fill',
  type: 'image'
}, {
  key: 'battle01',
  type: 'json',
  url: 'battle/battle01.json'
}, {
  key: 'question-mark',
  type: 'image',
  url: 'ui/question-mark-button.png'
}, {
  key: 'sponsor',
  type: 'image',
  url: 'battle/sponsor.png'
}, {
  key: 'currency',
  type: 'image',
  url: 'battle/currency.png'
}, {
  key: 'emp',
  type: 'image',
  url: 'battle/emp.png'
}, {
  key: 'call-bluff',
  type: 'image',
  url: 'battle/call-bluff.png'
}];

},{}],3:[function(require,module,exports){
/*
 * AreaTransition
 * ===============
 *
 * UI window for area transition
 */

'use strict';

var areas = require('../../static/assets/areas.json');

module.exports = AreaTransitionWindow;

function areaTransitionButtonToggle() {
  // unresponsive while animating
  if (this._isTweening)
    return;

  this._isTweening = true;
  var timeToTween = 500;  // milliseconds

  // hide panel
  if (this.panel.visible) {
    this._game.sound.play('swish-close');
    this._game.add.tween(this.panel).to(
        {x: 0 - this.panelWidth - this._memoryPadding}, timeToTween, Phaser.Easing.Exponential.Out, true
      ).onComplete.add(
        function () {
          this.panel.visible = false;
          this._isTweening = false;
        }, this
      );
    return;
  }

  // show panel

  // if memory bank window is open, close it
  if (this._game.memoryBankWindow.panel.visible) {
    this._game.memoryBankWindow.panel.visible = false;
  }

  this.panel.visible = true;
  this.display();
  //each time you press the button it should refresh the areas that it displays

  this.panel.x = 0 - this.panelWidth - this._memoryPadding;
  this._game.sound.play('swish-open');
  this._game.add.tween(this.panel).to(
      {x: this._baseX}, timeToTween, Phaser.Easing.Exponential.Out, true
    ).onComplete.add(function () { this._isTweening = false; }, this);
}

function AreaTransitionWindow(game/*, ...args*/) {
  Phaser.Group.call(this, game/*, ...args*/);

  this._game = game;

  // private members specifying margin and padding
  this._memoryTextOriginX = 100;
  this._memoryTextOriginY = 155;
  this._memoryPadding = 32;
  this._itemOriginX = 80;
  this._itemOriginY = 25;
  this._baseX = this._memoryPadding / 2;
  this._baseY = this._memoryPadding * 2;

  // memory bank window dimensions
  this.panelHeight = game.height * 1/2 - this._memoryPadding / 2;
  this.panelWidth = game.width - this._memoryPadding;
  this._rowCapacity = 5;  // items per row
  this._itemStart = 0;  // determines which row to show

  // window-dependent private member dimensions
  this._memoryTextWidth = this.panelWidth - 185;
  this._itemPadding = this.panelWidth / 50;
  this._nextOriginX = this.panelWidth - 55;
  this._nextOriginY = 0;
  this._prevOriginX = -18;
  this._prevOriginY = 0;

  /**
   * Panel
   */

  game.slickUI.add(
    this.panel = new SlickUI.Element.DisplayObject(
      this._baseX, this._baseY, game.make.sprite(0,0, 'memory-bank'),
      this.panelWidth, this.panelHeight));
  this.panel.displayObject.width = this.panelWidth;
  this.panel.displayObject.height = this.panelHeight;

  // by default, not displayed
  this.panel.visible = false;
  this.panel.alpha = 0.8;

  /**
   * Toggle button
   */
  // until you click on the toggle button
  game.slickUI.add(
    this.toggleButton = new SlickUI.Element.DisplayObject(
      this._memoryPadding,this._memoryPadding, game.make.button(0,0, 'button')));
  // set scale such that width = 1/8 panel width
  this.toggleButton.displayObject.scale.setTo(
    (this.panelWidth / 8) / this.toggleButton.displayObject.width);
  //this.toggleButton.x = game.width - this._memoryPadding - this.toggleButton.displayObject.width;
  // show panel callback
  this.toggleButton.events.onInputDown.add(areaTransitionButtonToggle, this);
  this.toggleButton.alpha = 0.9;

  var toggleStyle = { font: '14px Goudy Bookletter 1911', fill: '#48f2ff', boundsAlignH: 'center', boundsAlignV: 'middle'};
  this.toggleButton.add(
    this.toggleText = new SlickUI.Element.DisplayObject(0, 0, game.make.text(0, 0, 'AREAS', toggleStyle)));
  this.toggleText.displayObject.setTextBounds(0, this.toastTextY, this.toggleButton.displayObject.width, this.toggleButton.displayObject.height);

  /**
   * Text - name and description
   */
  var nameTextStyle = { font: '14px Goudy Bookletter 1911', fill: '#48f2ff', wordWrap: true, wordWrapWidth: this._memoryTextWidth, fontWeight: 'bold', boundsAlignH: 'center' };
  this.panel.add(
    this.nameText = new SlickUI.Element.DisplayObject(
      this._memoryTextOriginX,
      this._memoryTextOriginY,
      game.make.text(0,0, '', nameTextStyle), this._memoryTextWidth));
  // for alignment purposes
  var nameTextHeight = this.nameText.displayObject.getBounds().height;
  this.nameText.displayObject.setTextBounds(0,0, this._memoryTextWidth, nameTextHeight);

  var descTextStyle = { font: '14px Open Sans', fill: '#48f2ff', wordWrap: true, wordWrapWidth: this._memoryTextWidth, align: 'left' };
  this.panel.add(
    this.descText = new SlickUI.Element.DisplayObject(
      this._memoryTextOriginX,
      this._memoryTextOriginY + nameTextHeight,
      game.make.text(0,0, '', descTextStyle), this._memoryTextWidth));

  /**
   * Bookkeeping
   */
  // are we currently animating?
  this._isTweening = false;
  this._itemDisplayObjects = []; // for deletion purposes
  this._navButtons = [];
  this.areasToShow = Object.keys(areas).filter(function(area) {
    return areas[area]['navigable'] == true;
  });
}

AreaTransitionWindow.prototype = Object.create(Phaser.Group.prototype);
AreaTransitionWindow.prototype.constructor = AreaTransitionWindow;

// Utility functions: instantly hide or show panel/UI
AreaTransitionWindow.prototype.hidePanel = function () {
  this.panel.visible = false;
  this.panel.x = 0 - this.panelWidth - this._memoryPadding;
};

AreaTransitionWindow.prototype.disable = function () {
  this.hidePanel();
  this.toggleButton.visible = false;
  this.toggleButton.inputEnabled = false;
};

AreaTransitionWindow.prototype.enable = function () {
  this.hidePanel();
  this.toggleButton.visible = true;
  this.toggleButton.inputEnabled = true;
  //not sure that this will re-add listeners
};

AreaTransitionWindow.prototype.display = function () {
  this.cleanWindow();
  this.displayAreas();
  this.showNavButtons();
};

AreaTransitionWindow.prototype.cleanWindow = function () {
  for (var i = 0; i < this._itemDisplayObjects.length; i++) {
    var item = this._itemDisplayObjects[i];
    item.container.displayGroup.removeAll(true);
    item.container.displayGroup.destroy();
  }
  for (i = 0; i < this._navButtons.length; i++) {
    var navButton = this._navButtons[i];
    navButton.container.displayGroup.removeAll(true);
    navButton.container.displayGroup.destroy();
  }
  this._itemDisplayObjects = [];
  this._navButtons = [];
};

AreaTransitionWindow.prototype.displayAreas = function () {
  this.areasToShow = Object.keys(areas).filter(function(area) {
    let seen = this._game.player.seenAreas.includes(area);
    //this filter will add rooms seen in the past that should be avaliable in the window
    return areas[area]['navigable'] == true && this._game.room.name != area && seen;
  }, this);
  //this is going to leave things out, or have cycles
  // we will have to think carefully when adding this information to the json
  // do we want a given room to only appear if seen or do we want to have a group of
  // rooms all navigable from one another?
  // ie hanger must be reached first, but once there you have immediate access to talvine
  for (let area of this._game.room.area.areaAccess){
    if (!this.areasToShow.includes(area)){
      this.areasToShow.push(area);
    }
  }

  var itemEnd = this._itemStart + this._rowCapacity < this.areasToShow.length
    ? this._itemStart + this._rowCapacity
    : this.areasToShow.length;

  for (var i = this._itemStart; i < itemEnd; i++) {
    var itemId = this.areasToShow[i];

    // scaled width = 1/7 panel width;
    var desiredWidth = (this.panelWidth / 7);
    var assetSprite = this._game.make.sprite(0,0, itemId);
    assetSprite.scale.setTo(desiredWidth / assetSprite.width);

    var maskSprite = this._game.make.sprite(0,0, 'memory-bank-icon-mask');
    maskSprite.scale.setTo(desiredWidth / maskSprite.width);

    var maskedBmd = this._game.make.bitmapData(maskSprite.width, maskSprite.height);
    maskedBmd.alphaMask(assetSprite, maskSprite);

    var itemSprite = this._game.make.sprite(0,0, maskedBmd);
    var slickItem;
    this.panel.add(slickItem = new SlickUI.Element.DisplayObject(
      this._itemOriginX + (i - this._itemStart)*(this._itemPadding + itemSprite.width), this._itemOriginY,
      itemSprite));

    var borderSprite = this._game.make.sprite(0,0, 'memory-bank-icon');
    borderSprite.scale.setTo(desiredWidth / borderSprite.width);
    var slickBorder;
    this.panel.add(slickBorder = new SlickUI.Element.DisplayObject(
      this._itemOriginX + (i - this._itemStart)*(this._itemPadding + itemSprite.width), this._itemOriginY,
      borderSprite));

    itemSprite.inputEnabled = true;
    itemSprite.input.useHandCursor = true;
    itemSprite.events.onInputOver.add(function () {
      this.nameText.displayObject.text = areas[this.itemId]['name'].toUpperCase();
    }, {nameText: this.nameText, itemId: itemId});
    itemSprite.events.onInputUp.add(function() {
      this.game.room.loadArea(this.itemId);
    }, {game: this._game, itemId: itemId});
    itemSprite.events.onInputUp.add(areaTransitionButtonToggle, this);

    this._itemDisplayObjects.push(slickItem);
    this._itemDisplayObjects.push(slickBorder);
  }
};

AreaTransitionWindow.prototype.showNavButtons = function () {

  // next buttons
  if (this._itemStart + this._rowCapacity < this.areasToShow.length) {
    var nextButton = this._game.make.button(0,0,'memory-bank-next');
    var slickNext;
    this.panel.add(slickNext = new SlickUI.Element.DisplayObject(
      this._nextOriginX, this._nextOriginY, nextButton));
    // scaled by height, equal to panel height
    nextButton.scale.setTo(this.panelHeight / nextButton.height);
    this._navButtons.push(slickNext);

    nextButton.events.onInputUp.add(function () {
      this.switchRow(true);
      this.display();
    }, this);

  }

  // prev buttons
  if (this._itemStart > 0) {
    var prevButton = this._game.make.button(0,0,'memory-bank-next');
    // rotate sprite
    prevButton.anchor.setTo(0.5, 0.5);
    prevButton.scale.y *= -1;
    prevButton.anchor.setTo(1,1);

    var slickPrev;
    this.panel.add(slickPrev = new SlickUI.Element.DisplayObject(
      this._prevOriginX, this._prevOriginY,
      prevButton));
    this._navButtons.push(slickPrev);

    prevButton.scale.setTo(this.panelHeight / prevButton.height);

    prevButton.events.onInputUp.add(function () {
      this.switchRow(false);
      this.display();
    }, this);

  }
};

AreaTransitionWindow.prototype.switchRow = function (wantsNextRow) {
  if (wantsNextRow && this._itemStart + this._rowCapacity < this.areasToShow.length) {
    this._itemStart += this._rowCapacity;
    return;
  }
  if (!wantsNextRow && this._itemStart - this._rowCapacity >= 0) {
    this._itemStart -= this._rowCapacity;
    return;
  }
};

AreaTransitionWindow.prototype.update = function () {
  // TODO: Stub.
};

},{"../../static/assets/areas.json":31}],4:[function(require,module,exports){
'use strict';


function Argument(game, x, y, assetName, match, jsonIdx) {
  Phaser.Sprite.call(this, game, x, y, assetName);
  this.assetName = assetName;
  this.inputEnabled = true;
  this.input.useHandCursor = true;
  this.key = match;
  this.jsonIdx = jsonIdx;
  this.shown = false;
}

Argument.prototype = Object.create(Phaser.Sprite.prototype);
module.exports = Argument.prototype.constructor = Argument;

},{}],5:[function(require,module,exports){
/*
 * ArgumentManager
 * ===============
 *
 * Extension of ConversationManager for Logic Battles
 */

'use strict';

var ConversationManager = require('./ConversationManager');

module.exports = ArgumentManager;

function ArgumentManager(game, customActions/*, ...args*/) {
  // TODO:
  //   1. Edit constructor parameters accordingly.
  //   2. Adjust object properties.

  ConversationManager.call(this, game, customActions);
  this.nestedIdx = 0;
  this.currentParams = [];

  /* Signals */
  this.specialCompleteSignal = new Phaser.Signal();
  this.interludeCompleteSignal = new Phaser.Signal();

  /* PRIVATE */
  // TODO: remove companions from here!
  this.specialArgumentTypes = ['ability', 'intro', 'custom', 
    'lose', 'win', 'gameover', 'credits'];

}
ArgumentManager.prototype = Object.create(ConversationManager.prototype);
ArgumentManager.prototype.constructor = ArgumentManager;

ArgumentManager.prototype.update = function () {
  // TODO: Stub.
};

/** BEGIN OVERRIDE FUNCTIONS */
ArgumentManager.prototype.getResponses = function () {
  if (this.currentParams.length > 0) {
    return [{ 'target': this.nestedIdx+1, 'text': '[Next]', 'params': this.currentParams }];
  }

  return [];
};

ArgumentManager.prototype.advanceToTarget = function (targetIdx, params = []) {
  // pass along current parameters
  this.currentParams = params;
  if (params.length > 0) {
    if (this.specialArgumentTypes.includes(params[0])) {
      var customType = params[0];
      var custom = this.conversation[customType];

      if (params.length >= 2) {
        // Traverse through parameters
        for (var i = 1; i < params.length; i++) {
          if (params[i] in custom)
            custom = custom[params[i]];
        }
      }

      if (targetIdx in custom) {
        this.nestedIdx = targetIdx;
        return true;
      }

      // end of this conversation, go back to whatever we were doing
      this.currentParams = [];
      this.specialCompleteSignal.dispatch();
      return false; // do NOT refresh display on end of special argument; DialogueWindow waits for a display call

    } else if (params.length >= 2 && params[0] === 'interlude') {
      var interludeType = params[1];
      var argument = this.conversation[this.idx];

      if (interludeType in argument && targetIdx in argument[interludeType]) {
        this.nestedIdx = targetIdx;
        return true;
      }

      this.endArgInterlude();
      return false; // do NOT refresh display on end of argument interlude
    }
  }

  this.idx = targetIdx;
  return true;
};

ArgumentManager.prototype.endConversation = function() {
  this.customActions.customAction(this.conversation['onEnd']);  
};

ArgumentManager.prototype.getAvatar = function () {
  return 'invisible';
};

ArgumentManager.prototype.getCurrentText = function () {
  if (this.conversation === null)
    return '';

  var arg = this.getArgument();
  if (arg === null)
    return '';

  return arg['text'];
};

ArgumentManager.prototype.getSpeaker = function () {
  if (this.conversation === null) {
    return '';
  }

  var arg = this.getArgument();
  if (arg === null)
    return '';

  return arg['speaker']; 
};
/** END OVERRIDE FUNCTIONS */

ArgumentManager.prototype.getArgument = function () {
  if (this.currentParams.length > 0) {
    var params = this.currentParams;
    if (this.specialArgumentTypes.includes(params[0])) {
      // special argument
      // support for multiple params
      var customType = params[0];
      var custom = this.conversation[customType];

      if (params.length >= 2) {
        // Traverse through parameters
        for (var i = 1; i < params.length; i++) {
          var param = params[i];
          if (param in custom) {
            custom = custom[param];
          }
        }
      }

      return custom[this.nestedIdx];

    } else if (params.length >= 2 && params[0] === 'interlude') {
      // interlude
      return this.conversation[this.idx][params[1]][this.nestedIdx];
    }
  }

  return this.conversation[this.idx];
};

ArgumentManager.prototype.startInterlude = function (type) {
  this.nestedIdx = 0;
  this.currentParams = ['interlude', type];
};

ArgumentManager.prototype.endArgInterlude = function () {
  this.nestedIdx = 0;
  this.currentParams = [];
  this.interludeCompleteSignal.dispatch();
};

ArgumentManager.prototype.startSpecialArgument = function (/*... arguments*/) {
  this.nestedIdx = 0;
  for (var i = 0; i < arguments.length; i++)
    this.currentParams.push(arguments[i]);
};

ArgumentManager.prototype.getCurrentCounters = function () {
  return this.conversation[this.idx]['counters'];
};

ArgumentManager.prototype.isNumberProperty = function (property) {
  var n = Math.floor(Number(property));
  return String(n) == property;
};

ArgumentManager.prototype.getAllArguments = function () {
  // returns as an array
  var args = [];
  var keys = Object.keys(this.conversation);
  var prop;
  for (prop in keys) {
    if (this.isNumberProperty(prop) && prop in this.conversation) {
      args.push(this.conversation[prop]);
    }
  }
  return args;
};

ArgumentManager.prototype.getAllAbilities = function () {
  var abilities = [];
  if ('abilities' in this.conversation) {
    var i;
    for (i in this.conversation['abilities']) {
      abilities.push(this.conversation['abilities'][i]);
    }
  }
  return abilities;
};

ArgumentManager.prototype.setArgumentById = function (id) {
  for (var i = 0; i < this.conversation.length; i++) {
    if (this.conversation[i]['id'] === id) {
      this.idx = i;
      return;
    }
  }
};

ArgumentManager.prototype.takeActions = function() {
  var argument = this.getArgument();
  if (argument === null)
    return '';

  if ('actions' in argument) {
    for (var action in argument['actions']) {
      ConversationManager.prototype.takeAction.call(this, this._game, action, argument['actions'][action]);
    }
  }
};
},{"./ConversationManager":9}],6:[function(require,module,exports){
/*
 * BattleUi
 * ========
 *
 * User interface for Logic Battle mechanic
 */

'use strict';

module.exports = BattleUi;

var HealthBar = require('./HealthBar.js');
var Icon = require('./Icon');
var textstyles = require('../../static/assets/textstyles.json');
var npcs = require('../../static/assets/npcs.json');

function BattleUi(game, playerDeck, enemyDeck/*, ...args*/) {
  Phaser.Group.call(this, game/*, ...args*/);

  // - this.cardSignal
  // - this.cardAnimCompleteSignal
  // - this.argAnimCompleteSignal
  // - this.playerDeckIcons
  // - this.enemyDeckIcons
  // - this.credBar

  /** Signals */
  this.cardSignal = new Phaser.Signal();
  this.companionSignal = new Phaser.Signal();
  this.cardAnimCompleteSignal = new Phaser.Signal();
  this.argAnimCompleteSignal = new Phaser.Signal();

  this.playerDeckIcons = [];
  this.enemyDeckIcons = [];
  this.companionIcons = [];

  /** Private properties */
  this._game = game;
  this._portraitSize = 100;
  this._cardWidth = 70;
  this._cardHeight; // unspecified
  this._credSize = 85;
  this._enemyOriginY = game.height * 0.3;
  this._centerX = game.width / 2;
  this._argumentRadius = this._portraitSize;
  this._playerIconsPerRow = 4;

  /** Background + overlay (this._background, this._overlay) */
  var roomBg = game.make.sprite(0,0, game.room.area.id);
  game.add.existing(roomBg);

  this._background = game.add.sprite(0,0,'battle-background');
  this._background.width = game.width;
  this._background.height = game.height;
  this._background.alpha = 0.85;

  this._overlay = game.add.sprite(0,0,'battle-overlay');
  this._overlay.width = game.width;
  this._overlay.height = game.height;
  // hide overlay initially
  this._overlay.alpha = 0;

  /** Enemy display */
  var enemyBarConfig = {x: this._centerX, y: 50, height:20, width:150, flipped:true};
  this.persuadeBar = new HealthBar(game, enemyBarConfig);
  var enemyIcon = game.add.existing(new Icon(game,
    this._centerX - this._portraitSize/2, this._enemyOriginY - this._portraitSize/2,
    'gleaming-shoal-portrait', null, null, this._portraitSize));
  enemyIcon.alpha = 1;

  /** Enemy deck display */
  for (var i = 0; i < enemyDeck.length; i++) {

    var argIcon = game.add.existing(new Icon(game, 0,0,
      'question-mark', 'memory-bank-icon-mask', 'enemy-arg-icon', this._cardWidth));

    this.enemyDeckIcons.push({'id': enemyDeck[i].assetName, 'icon': argIcon});

  }
  this.positionArguments(game, false);

  /* Current argument position marker */
  var currentArgMarker = game.add.sprite(0, 0, 'enemy-arg-icon');
  currentArgMarker.scale.setTo(this._cardWidth * 1.2 / currentArgMarker.width);
  currentArgMarker.anchor.setTo(0.5, 0.5);

  currentArgMarker.x = this._centerX;
  currentArgMarker.y = this._enemyOriginY + this._argumentRadius;

  /** Player display */
  this.credIcon = new SlickUI.Element.DisplayObject(
    this._centerX - this._credSize/2, game.height * 5 / 8 - this._credSize / 2,
    new Icon(game, 0,0,
    'memory-bank-icon-mask', null, 'memory-bank-icon', this._credSize));
  game.slickUI.add(this.credIcon);
  this._cardHeight = this.credIcon.displayObject.height;

  this.credIcon.add(
    this.credText = new SlickUI.Element.DisplayObject(0, 0,
      game.make.text(0, 0, ''+this._game.cred, textstyles['credibility']))
  );
  this.credText.displayObject.setTextBounds(0, 0, this._credSize, this.credIcon.displayObject.height);

  /** Player deck display */
  for (i = 0; i < playerDeck.length; i++) {
    this.makeCardIcon(playerDeck[i]);
  }

  /** Companion display */
  for (i = 0; i < game.companions.length; i++) {
    var companionName = npcs[game.companions[i]]['name'];
    var companionAvatar = npcs[game.companions[i]]['avatar'];
    var companionIcon = game.add.existing(new Icon(game, 0,0,
      companionAvatar, 'memory-bank-icon-mask', 'companion-icon', this._cardWidth));
    companionIcon.borderSprite.tint = 0x00ffff;
    companionIcon.x = game.width * 1/5 + i*(this._cardWidth);
    companionIcon.y = this.credIcon.y - this._cardWidth / 2;

    var companionSignal = this.companionSignal;
    companionIcon.events.onInputDown.add(function () {
      companionSignal.dispatch(this.game, this.companionName);
    }, {game: game, companionName: companionName});

    companionIcon.inputEnabled = true;
    companionIcon.input.useHandCursor = true;

    this.companionIcons.push(companionIcon);
  }

}

BattleUi.prototype = Object.create(Phaser.Group.prototype);
BattleUi.prototype.constructor = BattleUi;

BattleUi.prototype.update = function () {
  // TODO: Stub.
};

BattleUi.prototype.makeCardIcon = function (card) {
  var deckOriginX = this._game.width * 3 / 5;
  var deckOriginY = this.credIcon.y + (this._credSize - this._cardWidth) / 2;

  var iconIdx = this.playerDeckIcons.length;

  // otherwise, make a new card icon
  var playerCardIcon = this._game.add.existing(new Icon(this._game, 0,0,
    card.assetName, 'memory-bank-icon-mask', 'memory-bank-icon', this._cardWidth));
  playerCardIcon.x = deckOriginX + iconIdx%this._playerIconsPerRow * this._cardWidth;
  playerCardIcon.y = deckOriginY - Math.floor(iconIdx/this._playerIconsPerRow) * this._cardHeight;

  var cardSignal = this.cardSignal;
  // send signal upon click and delete tooltip
  playerCardIcon.events.onInputDown.add(function () {
    cardSignal.dispatch(this.game, this.currentCard);
  }, {game: this._game, currentCard: card});

  playerCardIcon.inputEnabled = true;
  playerCardIcon.input.useHandCursor = true;

  this.playerDeckIcons.push(playerCardIcon);
  this.addTooltip(card, iconIdx,
    this._centerX + this._argumentRadius, this._enemyOriginY - this._argumentRadius);
  return playerCardIcon;
};

BattleUi.prototype.getArgIcon = function (argument) {
  for (var i = 0; i < this.enemyDeckIcons.length; i++) {
    var argIconWithIdx = this.enemyDeckIcons[i];
    if (argument.assetName === argIconWithIdx['id']) {
      return {'index': i, 'id': argIconWithIdx['id'], 'icon': argIconWithIdx['icon']};
    }
  }
  return {'index': -1, 'icon': null};
};

BattleUi.prototype.revealCurrent = function () {
  var currentIconWithId = this.enemyDeckIcons[0];
  currentIconWithId['icon'] = this.revealArgIcon(
    currentIconWithId['id'], currentIconWithId['icon']);
};

BattleUi.prototype.revealArgIcon = function (id, argIcon) {
  var trash = argIcon;
  var newIcon = this._game.add.existing(new Icon(this._game, 0,0,
    id, 'memory-bank-icon-mask', 'enemy-arg-icon', this._cardWidth));
  newIcon.x = argIcon.x;
  newIcon.y = argIcon.y;
  this._game.world.swap(argIcon, newIcon);  // swap display ordering
  trash.destroy();
  return newIcon;
};

BattleUi.prototype.getCardIcon = function (card) {
  for (var i = 0; i < this.playerDeckIcons.length; i++) {
    var cardIcon = this.playerDeckIcons[i];
    if (card.key === cardIcon.id) {
      return {'index': i, 'icon': cardIcon};
    }
  }
  return {'index': -1, 'icon': null};
};

BattleUi.prototype.startCorrectCardTween = function (cardIcon, cardIdx, targetedArg) {
  //this sounds best when it starts at click
  this._game.sound.play('correct-card');
  var tween = this._game.add.tween(cardIcon);
  tween.to(
    { x: targetedArg.x, y: targetedArg.y }, 1000,
    Phaser.Easing.Exponential.In, true, 0);

  // create fill sprite

  var shatterSprite = this._game.make.sprite(
    targetedArg.x + targetedArg.width/2,
    targetedArg.y + targetedArg.height/2, 'memory-bank-icon-fill');
  shatterSprite.alpha = 0;
  // add slight fudge factor
  shatterSprite.scale.setTo(this._cardWidth*1.05 / shatterSprite.width);
  shatterSprite.anchor.setTo(0.5, 0.5);
  this._game.add.existing(shatterSprite);
  var alphaTween = this._game.add.tween(shatterSprite);

  // start alpha tween after
  tween.onComplete.add(function () {
    alphaTween.to({ alpha: 1 }, 1000, Phaser.Easing.Exponential.In, true, 0);
    alphaTween.onComplete.add(function () {
      cardIcon.destroy();
      targetedArg.destroy();
      shatterSprite.destroy();
      // arguments update by themselves, player cards do not
      this.playerDeckIcons.splice(cardIdx, 1);
    }, this);
  }, this);

  // return the last tween in the chain
  return alphaTween;
};

BattleUi.prototype.startIncorrectCardTween = function (cardIcon, targetedArg) {
  var tween = this._game.add.tween(cardIcon);
  var originX = cardIcon.x;
  var originY = cardIcon.y;

  tween.to({ x: targetedArg.x, y: targetedArg.y }, 1000,
    Phaser.Easing.Exponential.InOut, false, 0);
  // add an additional tween to return to original position
  tween.onComplete.add(function () {
    this._game.sound.play('wrong-card');

  }, this);

  var lastTween = this._game.add.tween(cardIcon);
  lastTween.to({ x: originX, y: originY }, 1000,
    Phaser.Easing.Exponential.In, false, 0);

  tween.chain(lastTween).start();

  // return last tween in the chain
  return lastTween;
};

BattleUi.prototype.playCardAnimation = function (card, argument, isCorrect) {
  // find matching argument icon
  var targetedArg = undefined;
  for (var i = 0; i < this.enemyDeckIcons.length; i++) {
    var argIconId = this.enemyDeckIcons[i]['id'];
    if (argument.assetName === argIconId) {
      targetedArg = this.enemyDeckIcons[i]['icon'];
      break;
    }
  }
  if (typeof targetedArg === 'undefined')
    return;

  // find matching card icon
  for (i = 0; i < this.playerDeckIcons.length; i++) {
    var cardIcon = this.playerDeckIcons[i];
    if (card.key === cardIcon.id) {
      var lastTween;
      // play different animations on correct vs. incorrect card
      if (isCorrect) {
        lastTween = this.startCorrectCardTween(cardIcon, i, targetedArg);
      } else {
        lastTween = this.startIncorrectCardTween(cardIcon, targetedArg);
      }
      lastTween.onComplete.add(function () {
        if (card.multiUse && isCorrect)
          this.makeCardIcon(card);
        this.cardAnimCompleteSignal.dispatch(this._game);

      }, this);
      return;
    }
  }
};

BattleUi.prototype.updateArguments = function (args, currentArgIdx) {
  var newEnemyDeckIcons = [];

  for (var i = 0; i < args.length; i++) {
    var idx = currentArgIdx + i;
    if (idx >= args.length)
      idx -= args.length;

    // null argument
    if (typeof args[idx] === 'undefined' || args[idx] === null)
      continue;

    var argIconWithId = this.getArgIcon(args[idx]);
    // not found
    if (argIconWithId['index'] === -1) {
      // add a new argument icon
      argIconWithId['id'] = args[idx]['assetName'];
      argIconWithId['icon'] = this._game.add.existing(new Icon(this._game, 0,0,
        'question-mark', 'memory-bank-icon-mask', 'enemy-arg-icon', this._cardWidth));
      // TODO: hardcoded as center right now.
      argIconWithId['icon'].x = this._centerX - this._cardWidth/2;
      argIconWithId['icon'].y = this._enemyOriginY - this._cardWidth/2;
    }
    newEnemyDeckIcons.push({
      'id': argIconWithId['id'], 
      'icon': argIconWithId['icon']
    });
  }

  this.enemyDeckIcons = newEnemyDeckIcons;
};

BattleUi.prototype.positionArguments = function (game, isTweening = true) {
  var nArgs = this.enemyDeckIcons.length;
  var argIcon;

  if (!isTweening) {
    for (var i = 0; i < nArgs; i++) {
      argIcon = this.enemyDeckIcons[i]['icon'];
      argIcon.x = this._centerX + Math.sin(i / nArgs * 2*Math.PI) * this._argumentRadius - this._cardWidth / 2;
      argIcon.y = this._enemyOriginY + Math.cos(i / nArgs * 2*Math.PI) * this._argumentRadius - this._cardWidth / 2;
    }
    return;
  }

  var tweeningPositions = [];
  var tweens = [];
  for (var j = 0; j < nArgs; j++) {
    tweeningPositions.push(
      new Phaser.Point(
        this._centerX + Math.sin(j / nArgs * 2*Math.PI) * this._argumentRadius - this._cardWidth / 2,
        this._enemyOriginY + Math.cos(j / nArgs * 2*Math.PI) * this._argumentRadius - this._cardWidth / 2));
  }
  for (j = 0; j < nArgs; j++) {
    argIcon = this.enemyDeckIcons[j]['icon'];
    if (typeof argIcon === 'undefined' || argIcon === null)
      continue;
    tweens.push(game.add.tween(argIcon).to(
      { x: tweeningPositions[j].x, y: tweeningPositions[j].y},
      1000, Phaser.Easing.Quadratic.InOut, false, 0));
  }
  for (j = 0; j < tweens.length; j++) {
    // Notify completion of argument rotation
    if (j === 0) {
      tweens[j].onComplete.add(function () {
        this.argAnimCompleteSignal.dispatch(this._game);
      }, this);
    }
    tweens[j].start();
  }
};

/* Gives the impression of arguments randomizing. */
BattleUi.prototype.rouletteArguments = function () {
  var lastTween = null;
  for (var i = 0; i < this.enemyDeckIcons.length; i++) {
    lastTween = this._game.add.tween(this.enemyDeckIcons[i]['icon']).to(
      { x: this._centerX - this._cardWidth/2, y: this._enemyOriginY - this._cardWidth/2}, 
      1000, Phaser.Easing.Quadratic.InOut, true, 0);
  }
  return lastTween;
};

BattleUi.prototype.positionCards = function () {
  var deckOriginX = this._game.width * 3 / 5;
  var deckOriginY = this.credIcon.y + (this._credSize - this._cardWidth) / 2;

  for (var i = 0; i < this.playerDeckIcons.length; i++) {
    var tween = this._game.add.tween(this.playerDeckIcons[i]);
    tween.to({x: deckOriginX + i%this._playerIconsPerRow * this._cardWidth,
      y: deckOriginY - Math.floor(i/this._playerIconsPerRow) * this._cardHeight},
      300, Phaser.Easing.Quadratic.InOut, true, 0);
  }
};

BattleUi.prototype.battleStart = function () {
  this.cardsInputEnabled(true);
  this.revealCurrent();
};

BattleUi.prototype.introTweens = function () {
  var tweenTime = 500;
  this.tweenInOverlay(tweenTime);
  return this.tweenInBackgroundTint(tweenTime);
};

BattleUi.prototype.tweenInOverlay = function (tweenTime) {
  var tween = this._game.add.tween(this._overlay);
  tween.to( {alpha: 1}, tweenTime, Phaser.Easing.Exponential.In, true, 0);
  return tween;
};

BattleUi.prototype.tweenInBackgroundTint = function (tweenTime) {
  var tween = this._game.add.tween(this._background);
  tween.to( {tint: 0x33343a}, tweenTime, Phaser.Easing.Exponential.In, true, 0);
  return tween;
};

BattleUi.prototype.flickerOverlay = function () {
  var tween = this._game.add.tween(this._overlay);
  var timeLeft = 500; // half a second total
  var flickerTime = 10;
  var nFlickers = this._game.rnd.integerInRange(2,4);
  var defaultTint = this._overlay.tint;
  var tintColor = 0x333535;
  var firstTween = tween;

  for (var i = 0; i < nFlickers; i++) {
    // use up all remaining time if it is the last flicker
    var randTime = i == nFlickers - 1
      ? timeLeft
      : this._game.rnd.frac() * timeLeft;

    // flicker instantly if it's the first flicker
    var splitTime = i == 0 ? 0 : this._game.rnd.frac() * randTime;
    tween.to( { tint: tintColor }, flickerTime, Phaser.Easing.Linear.In, false, splitTime);

    var nextTween = this._game.add.tween(this._overlay);
    nextTween.to( { tint: defaultTint }, flickerTime, Phaser.Easing.Linear.In, false, randTime - splitTime);
    tween.chain(nextTween);

    tween = nextTween;
    timeLeft -= randTime;
  }
  firstTween.start();
};

BattleUi.prototype.updateCredBar = function (value, isDamage) {
  // damage indication
  if (isDamage) {
    this.flickerOverlay();
  }
  this.credText.displayObject.text = value;
  var originalTint = this.credText.displayObject.tint;
  var firstTween = this._game.add.tween(this.credText.displayObject);
  firstTween.to({ tint: 0x970B26 }, 100, Phaser.Easing.Linear.In, false, 0);
  var secondTween = this._game.add.tween(this.credText.displayObject);
  secondTween.to({ tint: originalTint }, 500, Phaser.Easing.Linear.In, false, 0);
  firstTween.chain(secondTween);
  firstTween.start();
};

BattleUi.prototype.updatePersuasionBar = function () {
  this.persuadeBar.setPercent(this._game.persuasion * 25);
};

BattleUi.prototype.cardsInputEnabled = function (isEnabled) {
  for (var i = 0; i < this.playerDeckIcons.length; i++) {
    this.playerDeckIcons[i].inputEnabled = isEnabled;
  }
  for (i = 0; i < this.companionIcons.length; i++) {
    this.companionIcons[i].inputEnabled = isEnabled;
  }
};

BattleUi.prototype.addTooltip = function (card, cardIdx, x, y) {
  var playerCardIcon = this.playerDeckIcons[cardIdx];

  var tooltip = function () {
    var tooltipWidth = 250;
    var tooltipHeight = 200;

    var bmd = this._game.add.bitmapData(tooltipWidth, tooltipHeight);
    bmd.ctx.beginPath();
    bmd.ctx.rect(0, 0, tooltipWidth, tooltipHeight);
    bmd.ctx.fillStyle = '#424d4f';
    bmd.ctx.fill();

    this._game.slickUI.add(this.tooltip = new SlickUI.Element.DisplayObject(
      x,y, this._game.make.sprite(0, 0, bmd)));
    this.tooltip.alpha = 0.8;

    var nameTextStyle = { font: '14px Goudy Bookletter 1911', fill: '#48f2ff', wordWrap: true, wordWrapWidth: tooltipWidth, fontWeight: 'bold', boundsAlignH: 'center' };
    var nameText = new SlickUI.Element.DisplayObject(0,0,
      this._game.make.text(0,0, card.getName().toUpperCase(), nameTextStyle));
    this.tooltip.add(nameText);
    // for alignment purposes
    var nameTextHeight = nameText.displayObject.getBounds().height;
    nameText.displayObject.setTextBounds(0,0, tooltipWidth, tooltipHeight);

    var descTextStyle = { font: '14px Open Sans', fill: '#48f2ff', wordWrap: true, wordWrapWidth: tooltipWidth, align: 'left' };
    var descText = new SlickUI.Element.DisplayObject(
      0, Math.round(nameTextHeight),
      this._game.make.text(0,0, card.getDescription(), descTextStyle));
    this.tooltip.add(descText);
  };

  var deleteTooltip = function () {
    if (this.tooltip) {
      this.tooltip.container.displayGroup.removeAll();
    }
    this.tooltip = undefined;
  };

  playerCardIcon.events.onInputDown.add(deleteTooltip, playerCardIcon);

  // tooltip functions
  playerCardIcon.events.onInputOver.add(tooltip, playerCardIcon);
  playerCardIcon.events.onInputOut.add(deleteTooltip, playerCardIcon);

};

},{"../../static/assets/npcs.json":33,"../../static/assets/textstyles.json":35,"./HealthBar.js":11,"./Icon":12}],7:[function(require,module,exports){
'use strict';

var items = require('../../static/assets/items.json');

function Card(game, x, y, assetName, multiUse = false) {
  Phaser.Sprite.call(this, game, x, y, assetName);
  this._game = game;
  this.assetName = assetName;
  this.key = assetName;
  this.description = 'test';
  this.multiUse = multiUse;
}

Card.prototype = Object.create(Phaser.Sprite.prototype);
module.exports = Card.prototype.constructor = Card;

Card.prototype.getName = function () {
  return items[this.key]['name'];
};

Card.prototype.getDescription = function () {
  return items[this.key]['desc'];
};

},{"../../static/assets/items.json":32}],8:[function(require,module,exports){
/*
* Clickable
* ====
*
* A sample prefab (extended game object class), displaying a clickable object in a room.
*/

'use strict';

var Toast = require('./Toast');
var items = require('../../static/assets/items.json');

function Clickable(game, x, y, id, height, width) {
  Phaser.Sprite.call(this, game, x, y, id);
  this.height = height;
  this.width = width;

  this._game = game;
  this.id = id;
  this.name = items[this.id]['name'];
  this.anchor.set(0.5);
  this.alpha = 0.5;
  this.inputEnabled = true;
  this.input.useHandCursor = true;
  this.events.onInputDown.add(click, this);
  this.events.onInputOver.add(mouseover, this);
  this.events.onInputOut.add(mouseout, this);

  this.input.pixelPerfectOver = true;   // checks pixels so that collision only happens with non-transparent areas
                                        // computationally expensive, but maybe necessary for realism purposes?
}

function click() {
  this._game.sound.play('inventory-add');
  this.destroy();
  this._game.add.existing(new Toast(this._game, 'You\'ve acquired ' + this.name + '!', 5));
  this._game.player.inventory.push(this.id);
  var items = this._game.room.area.items;
  var remove_item = -1;
  //because it is checking the id of the item and not the actual item
  for (let i = 0; i < items.length; i++) {
    if (items[i].id === this.id){
      remove_item = i;
    }
  }
  if (remove_item > -1) {
    items.splice(remove_item, 1);
  }
  this._game.dialogueWindow.display(true); // refresh dialogue display, display instantly
  this._game.memoryBankWindow.display();  // refresh memory bank display
}

function mouseover() {
  this.alpha = 1;
  this._game.add.existing(this.toast = new Toast(this._game, this.name, 5));
}

function mouseout() {
  if (this.toast) {
    this.toast.toast.container.displayGroup.removeAll();
    this.toast.destroy();
  }
}

Clickable.prototype = Object.create(Phaser.Sprite.prototype);
module.exports = Clickable.prototype.constructor = Clickable;

},{"../../static/assets/items.json":32,"./Toast":21}],9:[function(require,module,exports){
/*
 * ConversationManager
 * ===================
 *
 * Handles loading JSON assets for conversation and managing conversation state
 */

'use strict';

module.exports = ConversationManager;

var npcs = require('../../static/assets/npcs.json');

function ConversationManager(game, customActions/*, ...args*/) {
  // PROPERTIES:
  // - conversation - json conversation

  this._game = game;
  this.customActions = customActions;

  this.conversation = null;
  this.idx = 0;
  this.shown = [];
}
ConversationManager.prototype.constructor = ConversationManager;

/* Assumes JSON has already been loaded into cache!
 * Use game.load.json otherwise
 */
ConversationManager.prototype.loadJSONConversation = function (jsonKey) {
  var json = this._game.cache.getJSON(jsonKey);

  this.conversation = json;

  if (this._game.areaTransitionWindow !== null 
    && typeof this._game.areaTransitionWindow !== 'undefined') {
    this._game.areaTransitionWindow.disable();
  }
  //the player object will initialize the start index of a conversation
  // at the end of a conversation the index will return to 0
  // so that the next file will start at the begining.

};

ConversationManager.prototype.getCurrentText = function () {
  if (this.conversation === null) {
    return '';
  }

  return this.conversation[this.idx]['text'];
};

ConversationManager.prototype.getResponses = function () {
  if (!this.conversation === null) {
    return [''];
  }
  var responses = this.conversation[this.idx]['responses'];
  var ret = [];
  for (var i = 0; i < responses.length; i++) {
    //check showOnce of target node
    if (this.shown.indexOf(responses[i]['target']) > -1) {    // this node is marked "show once" and has already been shown
      continue;
    }
    //check conditions on response
    if ('conditions' in responses[i]) {
      var conditionsNeeded = 0;
      var conditionsMet = 0;
      for (var condition in responses[i]['conditions']) {
        if (this.checkCondition(this._game, condition, responses[i]['conditions'][condition])) {
          conditionsMet++;
        }
        conditionsNeeded++;
      }
      if (conditionsMet >= conditionsNeeded) {
        ret.push(responses[i]); //if all conditions are met, display response
      }
    } else {
      ret.push(responses[i]);   //no conditions on this response, display it
    }
  }

  return ret;
};

ConversationManager.prototype.checkCondition = function(game, condition, value) {
  if (condition.startsWith('var')) {
    var variable = condition.substring(3);
    if (value.startsWith('!')) {
      if (!(variable in game.player.variables) || game.player.variables[variable] !== value.substring(1)) {
        return true;    //player does not have this variable set, or has it set to a different value
      }
    } else if (variable in game.player.variables && game.player.variables[variable] === value) {
      return true;      //player has this variable set to this value
    }
  } else if (condition.startsWith('inv')) {
    var item = condition.substring(3);
    if (value.startsWith('!')) {
      if (game.player.inventory.indexOf(item) === -1) {
        return true;    //player does not have this inventory item
      }
    } else if (game.player.inventory.indexOf(item) > -1) {
      return true;      //player has this inventory item
    }
  } else if (condition.startsWith('seen')) {
    var visited = value.split(' ');
    var visitedAll = true;
    for (var i = 0; i < visited.length; i++) {
      if (this.shown.indexOf(parseInt(visited[i])) === -1) {
        visitedAll = false;
      }
    }
    return visitedAll;
  }
  return false;
};

ConversationManager.prototype.getSpeaker = function () {
  if (this.conversation === null) {
    return [''];
  }

  return npcs[this.conversation[this.idx]['speaker']]['name'];
};

ConversationManager.prototype.getAvatar = function() {
  if (this.conversation === null) {
    return [''];
  }

  return npcs[this.conversation[this.idx]['speaker']]['avatar'];
};

ConversationManager.prototype.takeActions = function() {
  if (this.conversation === null) {
    return;
  }

  if (this.conversation[this.idx]['showOnce'] === 1 && !this.shown.includes(this.idx)) {
    //if save at this point keeps getting resaved.
    this.shown.push(this.idx);
  }

  if (this.conversation[this.idx]['actions'].length === 0) {
    return;
  }

  for (var action in this.conversation[this.idx]['actions']) {
    this.takeAction(this._game, action, this.conversation[this.idx]['actions'][action]);
  }
  return;
};

ConversationManager.prototype.takeAction = function(game, action, value) {
  if (action.startsWith('var')) {
    var variable = action.substring(3);
    if (value.startsWith('!')) {
      delete game.player.variables[variable]; //remove variable from
    } else {
      game.player.variables[variable] = value;  //set variable on player
    }
  } else if (action.startsWith('inv')) {
    var item = action.substring(3);
    if (value.startsWith('!')) {
      if (!(item in game.player.inventory)) {
        var index = game.player.inventory.indexOf(item);
        if (index > -1) {
          game.player.inventory.splice(index, 1); //remove item from player inventory
        }
      }
    } else {
      game.player.inventory.push(item); //add item to player inventory
    }
  } else if (action === 'custom') {
    this.customActions.customAction(value);
  }
};

ConversationManager.prototype.endConversation = function() {
  if (this.conversation === null) {
    return;
  }

  for (var i = 0; i < this._game.room.npcs.length; i++) {
    var npc = this._game.room.npcs[i];
    npc.show();
  }
    
  if ('onEnd' in this.conversation) {
    this.customActions.customAction(this.conversation['onEnd']);
  }

  this.shown = [];
  this.idx = 0;
  //think this is a cyclic ref. TODO: fix 
  this._game.dialogueWindow.convoFile = null;
  this._game.areaTransitionWindow.enable();
};

ConversationManager.prototype.advanceToTarget = function (targetIdx) {
  this.idx = targetIdx;
  return true;  // returns whether should refresh display.
};

ConversationManager.prototype.update = function () {
  // TODO: Stub.
};

},{"../../static/assets/npcs.json":33}],10:[function(require,module,exports){
/*
* DialogueWindow
* ==============
*
* Handles displaying dialogue (conversation data) to screen
*/

'use strict';

module.exports = DialogueWindow;

var Scrollbar = require('./Scrollbar');
var textstyles = require('../../static/assets/textstyles.json');

function DialogueWindow(game, convoManager/*, ...args*/) {
  Phaser.Group.call(this, game/*, ...args*/);

  // PROPERTIES
  // - dialogPanel
  // - speakerText
  // - dialogText
  // - convoManager (passed in ConversationManager)
  // - dialogWidth
  // - dialogHeight
  // - buttons

  this.convoManager = convoManager;
  // messy, but useful if we need a reference to the game
  this._game = game;

  /* SIGNALS */
  // private
  this._onDialogTextFinished = new Phaser.Signal(); // when the char-by-char display finishes

  // private members specifying margin and padding
  this._dialogTextOriginX = 96;
  this._dialogTextOriginY = 60;
  this._dialogPadding = 32;

  // speaker avatar display
  game.slickUI.add(this.avatar = new SlickUI.Element.DisplayObject(
    400, 100, game.make.sprite(0, 0, 'invisible'),
    400, 500));

  this.dialogHeight = game.height * 3 / 8 /* 3/8 height */ - this._dialogPadding / 2;
  this.dialogWidth = game.width - this._dialogPadding;

  // dialog text dimensions (private)
  this._dialogTextHeight = this.dialogHeight - this._dialogTextOriginY - 18;
  this._dialogTextWidth = this.dialogWidth - 185;

  // window coordinates
  var dialogX = this._dialogPadding / 2;
  var dialogY = game.height * 5 / 8;  // 5/8 down

  game.slickUI.add(
    this.dialogPanel = new SlickUI.Element.DisplayObject(
      dialogX, dialogY, game.make.sprite(0,0, 'dialogue-panel'),
      this.dialogWidth, this.dialogHeight));
  this.dialogPanel.displayObject.width = this.dialogWidth;
  this.dialogPanel.displayObject.height = this.dialogHeight;

  // actual window contents
  var speakerX = this._dialogPadding + 64;
  var speakerY = this._dialogPadding / 4;
  this.dialogPanel.add(
    this.speakerText = new SlickUI.Element.DisplayObject(
      Math.round(speakerX), speakerY,
      game.make.text(0, 0, 'Speaker', textstyles['speaker'])));

  // using a mask for scrolling purposes
  this._scrollMask = game.make.graphics(0, 0);
  this._scrollMask.beginFill(0xffffff);
  this._scrollMask.drawRect( this._dialogTextOriginX, this._dialogTextOriginY, this._dialogTextWidth, this._dialogTextHeight );
  this._scrollMask.endFill();

  var bodyStyle = textstyles['dialogueBody'];
  bodyStyle.wordWrapWidth = this._dialogTextWidth;
  this.dialogPanel.add(
    this.dialogText = new SlickUI.Element.DisplayObject(this._dialogTextOriginX, this._dialogTextOriginY, 
      game.make.text(0, 0, 'placeholder text', bodyStyle)));
  this.dialogText.displayObject.lineSpacing = 0;

  this.dialogPanel.add(new SlickUI.Element.DisplayObject(0, 0, this._scrollMask));
  this.dialogText.displayObject.mask = this._scrollMask;

  this.dialogPanel.alpha = 0.8;

  // for removing player choice buttons
  this.buttons = [];
  this.buttonTweens = [];
  // slider for scrolling overflow
  this.slider = null;
  // stores each button Y value
  // also keeps track of how low our content goes; last element is content bottom
  this._buttonsY = [];

  //for keeping track of whether the avatar needs to be updated (performance intensive)
  this.avatarName = 'invisible';

  // will track the conversation file, so that save checkpoints will
  // go to the correct area in the conversation
  this.convoFile = null;

  // for rendering lines character by character
  this.charTimer = null;
}

DialogueWindow.prototype = Object.create(Phaser.Group.prototype);
DialogueWindow.prototype.constructor = DialogueWindow;

DialogueWindow.prototype.begin = function(jsonKey) {
  if (jsonKey) {
    this.loadJSONConversation(jsonKey);
    this.show();
    this.display();
  } else {
    this.hide();
  }
};

DialogueWindow.prototype.loadJSONConversation = function (jsonKey) {
  if (jsonKey) {
    this.convoFile = jsonKey;
    this.convoManager.loadJSONConversation(jsonKey);
  }
};

DialogueWindow.prototype.display = function (displaysInstant = false 
                              /* by default, not set to display text instantly */) {
  this.cleanWindow();
  if (this.convoFile) {
    this.takeActions();
    this.displayAvatar();

    // On finishing the dialog text display, display our responses
    // Added before our actual display call in case we display instantly
    this._onDialogTextFinished.add(function () {
      this.displayResponses();
      this._onDialogTextFinished.removeAll();
    }, this);
    this.displayText(displaysInstant);
  }
};

DialogueWindow.prototype.cleanWindow = function () {
  // stop all button tweens
  for (var i = 0; i < this.buttonTweens.length; i++) {
    this.buttonTweens[i].stop();
  }

  // remove all buttons
  for (var j = 0; j < this.buttons.length; j++) {
    var button = this.buttons[j];
    button.container.displayGroup.removeAll(true);
    button.container.displayGroup.destroy();
    button.container.children = [];
    button.container = undefined;
    button.sprite = undefined;
  }
  this.buttons = [];
  this._buttonsY = [];

  // remove scroller and restore dialog text position
  if (this.slider !== null) {
    this.slider.destroy();
    this.slider = null;
  }
  this.dialogText.y = this._dialogTextOriginY;
  this.dialogText.displayObject.inputEnabled = false;
  this.dialogText.displayObject.events.onInputOver.removeAll();
  this.dialogText.displayObject.events.onInputOut.removeAll();
  this._game.input.mouse.mouseWheelCallback = null;
};

DialogueWindow.prototype.takeActions = function() {
  this.convoManager.takeActions(this._game);
};

// if avatar needs to change, fade out the current one and fade in the new one
DialogueWindow.prototype.displayAvatar = function() {
  var speaker = this.convoManager.getAvatar();
  var fadeOut = 200;
  var fadeIn = 200;
  if (speaker !== this.avatarName) {
    var fadeInTween = this._game.add.tween(this.avatar);
    fadeInTween.to({alpha: 0}, fadeOut, Phaser.Easing.Linear.None, true);
    fadeInTween.onComplete.add(function() {
      this.avatar.displayObject.loadTexture(speaker);
      this._game.add.tween(this.avatar).to({alpha: 1}, fadeIn, Phaser.Easing.Linear.None, true);
    }, this);
    this.avatarName = speaker;
  }
};

DialogueWindow.prototype.displayText = function (displaysInstant) {
  this.speakerText.displayObject.text = this.convoManager.getSpeaker().toUpperCase();
  this.dialogText.displayObject.mask = this._scrollMask;

  if (displaysInstant) {
    this.dialogText.displayObject.text = this.convoManager.getCurrentText();
    if (this.charTimer != null) {
      this._game.time.events.remove(this.charTimer);  // stop characters from rendering one by one, if they are currently rendering
    }
    this._onDialogTextFinished.dispatch();
    return;
  }

  // character-by-character display
  this.displayCurrentLine();
  
};

DialogueWindow.prototype.displayResponses = function () {
  // start rendering buttons at the bottom of dialogue
  var responses = this.convoManager.getResponses(this._game);

  var textBottom = this._dialogTextOriginY + this.dialogText.displayObject.getBounds().height;
  this.nextButtonY = textBottom;

  if (responses.length === 0) {
    // no responses - waiting on player to do something to progress
    var waitButton = this.addChoiceButton(this._dialogTextOriginX, this.nextButtonY,
      'END', null);
    waitButton.visible = false;
    this.buttons.push(waitButton);
  }

  this.buttonTweens = [];

  for (var i = 0; i < responses.length; i++) {
    // pass along special parameters, if any
    var params = [];
    if ('params' in responses[i]) {
      params = responses[i]['params'];
    }

    // keep track of buttons to be deleted
    var responseDelay = 250;
    var button = this.addChoiceButton(
      this._dialogTextOriginX, this.nextButtonY,
      responses[i]['text'], responses[i]['target'], params);
    button.alpha = 0;
    var tween = this._game.add.tween(button).to({alpha: 1}, responseDelay, Phaser.Easing.Linear.None, true, responseDelay * i);
    if (i === responses.length - 1) {
      tween.onComplete.add(function() {
        this.addOverflowScroll();
      }, this);
    }
    this.buttonTweens.push(tween);  // for deletion later
    this.buttons.push(button);
    this._buttonsY.push(button.y);
    this.nextButtonY += button.sprite.height;
  }

  // last element is bottom of content
  this._buttonsY.push(this.nextButtonY);
};

DialogueWindow.prototype.addChoiceButton = function (x, y, responseTextField, responseTarget, responseParams = []) {
  // display text
  var buttonSidePadding = 32;
  var buttonTextStyle = textstyles['choiceButton'];
  buttonTextStyle.wordWrapWidth = this._dialogTextWidth - buttonSidePadding;
  var responseText = this._game.make.text(0, 0, responseTextField, buttonTextStyle);
  var buttonText = new SlickUI.Element.DisplayObject(
    Math.round(this._dialogTextWidth / 2 - responseText.width / 2),0, /* center text */
    responseText);

  // add to sized button
  var choiceButton;
  this.dialogPanel.add(choiceButton = new SlickUI.Element.DisplayObject(
    x, y,
    this._game.make.button(0,0, 'dialogue-choice-button'),
    this.dialogWidth, responseText.height));
  choiceButton.add(buttonText);
  choiceButton.sprite.width = this._dialogTextWidth;
  choiceButton.sprite.height = responseText.height;

  // end of conversation. action deletes window
  if (responseTarget < 0) {
    choiceButton.events.onInputUp.add(
      function () {
        this.dialogueWindow.hide();
        this.dialogueWindow.convoManager.endConversation();  // take any actions that trigger when this conversation ends
      }, {dialogueWindow: this});
  }

  choiceButton.events.onInputUp.add(
    function () {
      var shouldRefresh = this.dialogueWindow.convoManager.advanceToTarget(
        this.responseTarget, this.responseParams);
      if (shouldRefresh)
        this.dialogueWindow.display();
    }, {dialogueWindow: this, responseTarget: responseTarget, responseParams: responseParams});
  // add mask
  choiceButton.sprite.mask = this._scrollMask;
  buttonText.displayObject.mask = this._scrollMask;

  return choiceButton;
};

DialogueWindow.prototype.addOverflowScroll = function () {
  // can we fit everything in the current window?
  var heightDiff = this._buttonsY[this._buttonsY.length - 1]
    - (this._dialogTextOriginY + this._dialogTextHeight);
  // add a slider otherwise
  if (heightDiff > 0) {

    var scrolllineWidth = 1.5;
    this.slider = new Scrollbar(
      this._game,
      this._dialogTextOriginX + this._dialogTextWidth + this._dialogPadding - scrolllineWidth,
      this._dialogTextOriginY - scrolllineWidth,
      this.dialogPanel, // parent
      {
        'x': [0, this._dialogPadding, 0],
        'y': [0, this._dialogTextHeight / 2, this._dialogTextHeight]
      },
      heightDiff, scrolllineWidth);

    var scrollCallback = function (value) {
      // mapping height differences to scroll values
      var scrollValue = heightDiff*value;
      this.dialogText.y = this._dialogTextOriginY - scrollValue;
      for (var i = 0; i < this.buttons.length; i++) {
        // slide all buttons up
        this.buttons[i].y = this.dialogPanel.y + this._buttonsY[i] - scrollValue;
      }
    };

    this.slider.onDrag.add(scrollCallback, this);
    this.slider.onSetValue.add(scrollCallback, this);

    // Mouse wheel events
    this.dialogText.displayObject.inputEnabled = true;
    this.dialogText.displayObject.events.onInputOver.add(
      function () { this._dialogOver = true; }, this);
    this.dialogText.displayObject.events.onInputOut.add(
      function () { this._dialogOver = false; }, this);
    this._game.input.mouse.mouseWheelCallback = (function (event) {
      if (!this._dialogOver)
        return;
      this.slider.value += (1/heightDiff) * event.deltaY;
    }).bind(this);
  }
};

DialogueWindow.prototype.showAvatar = function() {
  var fadeInTween = this._game.add.tween(this.avatar);
  var fadeIn = 200;
  fadeInTween.to({alpha: 1}, fadeIn, Phaser.Easing.Linear.None, true);
};

DialogueWindow.prototype.hideAvatar = function() {
  var fadeOutTween = this._game.add.tween(this.avatar);
  var fadeOut = 200;
  fadeOutTween.to({alpha: 0}, fadeOut, Phaser.Easing.Linear.None, true);
};

DialogueWindow.prototype.show = function() {
  this.dialogPanel.visible = true;
  this.showAvatar();
};

DialogueWindow.prototype.hide = function () {
  this.cleanWindow();
  this.dialogPanel.visible = false;
  this.hideAvatar(); //hide avatar
};

DialogueWindow.prototype.displayCurrentLine = function () {

  var line = this.convoManager.getCurrentText();
  this.dialogText.displayObject.text = '';

  //  Split the current line on characters, so one char per array element
  var split = line.split('');

  //  Reset the word index to zero (the first word in the line)
  this._cIndex = 0;

  // Add an option to skip the text on clicking down.
  this.dialogPanel.displayObject.inputEnabled = true;
  this.dialogPanel.events.onInputDown.add(this.skipText, this);

  var nextChar = function () {
    // TODO: make this a selectable option
    var delay = 3;
    
    this.dialogText.displayObject.text =
      this.dialogText.displayObject.text.concat(split[this._cIndex]);
    if (split[this._cIndex] === ',') {
      delay = 200;    // brief pause on commas
    } else if (['.', '?', '!'].indexOf(split[this._cIndex]) > -1) {
      delay = 300;    // longer pause after each sentence
    }
    this._cIndex++;
    if (this._cIndex == split.length) {
      // Tell the window when we're done
      this._onDialogTextFinished.dispatch();
      this.charTimer = null;
    } else {
      // Add the next event in the chain
      this.charTimer = this._game.time.events.add(delay, nextChar, this);
    }
  };

  //  Call the 'nextChar' function and chain until it reaches the end of the line
  this.charTimer = this._game.time.events.add(0, nextChar, this);

};

DialogueWindow.prototype.skipText = function () {
  this._game.time.removeAll();
  this.displayText(true);
  this.dialogPanel.events.onInputDown.removeAll();
};

DialogueWindow.prototype.update = function () {
  // TODO: Stub.
};

},{"../../static/assets/textstyles.json":35,"./Scrollbar":19}],11:[function(require,module,exports){
/**
Copyright (c) 2015 Belahcen Marwane (b.marwane@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

var HealthBar = function(game, providedConfig) {
  this.game = game;

  this.setupConfiguration(providedConfig);
  this.setPosition(this.config.x, this.config.y);
  this.drawBackground();
  this.drawHealthBar();
  this.setFixedToCamera(this.config.isFixedToCamera);
};
HealthBar.prototype.constructor = HealthBar;

HealthBar.prototype.setupConfiguration = function (providedConfig) {
  this.config = this.mergeWithDefaultConfiguration(providedConfig);
  this.flipped = this.config.flipped;
};

HealthBar.prototype.mergeWithDefaultConfiguration = function(newConfig) {
  var defaultConfig= {
    width: 250,
    height: 40,
    x: 0,
    y: 0,
    bg: {
      color: '#808080'
    },
    bar: {
      color: '#651828'
    },
    animationDuration: 200,
    flipped: false,
    isFixedToCamera: false
  };
    
  if(newConfig.flipped) {
    defaultConfig.bg.color = '#651828';
    defaultConfig.bar.color = '#808080';
  }
    
  return mergeObjects(defaultConfig, newConfig);
};

function mergeObjects(targetObj, newObj) {
  for (var p in newObj) {
    try {
      targetObj[p] = newObj[p].constructor==Object ? mergeObjects(targetObj[p], newObj[p]) : newObj[p];
    } catch(e) {
      targetObj[p] = newObj[p];
    }
  }
  return targetObj;
}

HealthBar.prototype.drawBackground = function() {

  var bmd = this.game.add.bitmapData(this.config.width, this.config.height);
  bmd.ctx.fillStyle = this.config.bg.color;
  bmd.ctx.beginPath();
  bmd.ctx.rect(0, 0, this.config.width, this.config.height);
  bmd.ctx.fill();

  this.bgSprite = this.game.add.sprite(this.x, this.y, bmd);
  this.bgSprite.anchor.set(0.5);

  if(this.flipped){
    this.bgSprite.scale.x = -1;
  }
};

HealthBar.prototype.drawHealthBar = function() {
  var bmd = this.game.add.bitmapData(this.config.width, this.config.height);
  bmd.ctx.fillStyle = this.config.bar.color;
  bmd.ctx.beginPath();
  bmd.ctx.rect(0, 0, this.config.width, this.config.height);
  bmd.ctx.fill();

  this.barSprite = this.game.add.sprite(this.x - this.bgSprite.width/2, this.y, bmd);
  this.barSprite.anchor.y = 0.5;

  if(this.flipped){
    this.barSprite.scale.x = -1;
  }
};

HealthBar.prototype.setPosition = function (x, y) {
  this.x = x;
  this.y = y;

  if(this.bgSprite !== undefined && this.barSprite !== undefined){
    this.bgSprite.position.x = x;
    this.bgSprite.position.y = y;

    this.barSprite.position.x = x - this.config.width/2;
    this.barSprite.position.y = y;
  }
};


HealthBar.prototype.setPercent = function(newValue){
  if (newValue < 0) newValue = 0;
  if (newValue > 100) newValue = 100;

  var newWidth = (newValue * this.config.width) / 100;

  this.setWidth(newWidth);
};

HealthBar.prototype.setWidth = function(newWidth){
  if (this.flipped) {
    newWidth = -1 * newWidth;
  }
  this.game.add.tween(this.barSprite).to( { width: newWidth }, this.config.animationDuration, Phaser.Easing.Linear.None, true);
};

HealthBar.prototype.setFixedToCamera = function(fixedToCamera) {
  this.bgSprite.fixedToCamera = fixedToCamera;
  this.barSprite.fixedToCamera = fixedToCamera;
};

HealthBar.prototype.kill = function() {
  this.bgSprite.kill();
  this.barSprite.kill();
};

module.exports = HealthBar;

},{}],12:[function(require,module,exports){
/*
 * Icon
 * ====
 *
 * Icon base class (masked sprite group)
 */

'use strict';

module.exports = Icon;

function Icon(game, x, y, asset, mask, border, width = 100.0/*, TODO: height = 100.0 ...args*/) {
  Phaser.Sprite.call(this, game, x, y, asset/*, ...args*/);

  // PROPERTIES
  // - maskSprite
  this.maskSprite;
  // - borderSprite
  this.borderSprite;
  // - asset key
  this.id = asset;

  this._game = game;
  // expands borders of mask slightly
  var scaleRelax = 1.05;

  if (typeof mask !== 'undefined' && mask !== null) {
    this.maskSprite = game.make.sprite(x,y, mask);

    this.maskSprite.scale.setTo(this.width*scaleRelax / this.maskSprite.width);

    var maskedBmd = game.make.bitmapData(this.maskSprite.width, this.maskSprite.height);
    maskedBmd.alphaMask(this, this.maskSprite);
    // replace main sprite with bitmap data mask
    this.loadTexture(maskedBmd);
  }

  this.scale.setTo(width / this.width);
  var parentScale = this.scale.x;

  if (typeof border !== 'undefined' && border !== null) {
    this.borderSprite = game.make.sprite(0,0, border);
    this.addChild(this.borderSprite);
    this.borderSprite.scale.setTo((width / this.borderSprite.width) / parentScale);
  }

}

Icon.prototype = Object.create(Phaser.Sprite.prototype);
Icon.prototype.constructor = Icon;

Icon.prototype.update = function () {
  var i = this.children.length;
  while (i--) {
    this.getChildAt(i).update();
  }
};

},{}],13:[function(require,module,exports){
/*
 * MemoryBankWindow
 * ===============
 *
 * UI window for the memory bank
 */

'use strict';

var items = require('../../static/assets/items.json');
var Icon = require('./Icon');

module.exports = MemoryBankWindow;

function memoryBankButtonToggle() {
  // unresponsive while animating
  if (this._isTweening)
    return;

  this._isTweening = true;
  var timeToTween = 500;  // milliseconds

  // hide panel
  if (this.panel.visible) {
    this._game.sound.play('swish-close');
    this._game.add.tween(this.panel).to(
        {x: this._baseX + this.panelWidth + this._memoryPadding}, timeToTween, Phaser.Easing.Exponential.Out, true
      ).onComplete.add(
        function () {
          this.panel.visible = false;
          this._isTweening = false;
        }, this
      );
    return;
  }

  // show panel

  // if area transition window is open, close it
  if (this._game.areaTransitionWindow.panel.visible) {
    this._game.areaTransitionWindow.panel.visible = false;
  }
  this.panel.visible = true;
  this.display();

  this.panel.x = this._baseX + this.panelWidth + this._memoryPadding;
  this._game.sound.play('swish-open');
  this._game.add.tween(this.panel).to(
      {x: this._baseX}, timeToTween, Phaser.Easing.Exponential.Out, true
    ).onComplete.add(function () { this._isTweening = false; }, this);
}

function MemoryBankWindow(game/*, ...args*/) {
  Phaser.Group.call(this, game/*, ...args*/);

  this._game = game;

  // private members specifying margin and padding
  this._memoryTextOriginX = 100;
  this._memoryTextOriginY = 155;
  this._memoryPadding = 32;
  this._itemOriginX = 80;
  this._itemOriginY = 25;
  this._baseX = this._memoryPadding / 2;
  this._baseY = this._memoryPadding * 2;

  // memory bank window dimensions
  this.panelHeight = game.height * 1/2 - this._memoryPadding / 2;
  this.panelWidth = game.width - this._memoryPadding;
  this._rowCapacity = 5;  // items per row
  this._itemStart = 0;  // determines which row to show

  // window-dependent private member dimensions
  this._memoryTextWidth = this.panelWidth - 185;
  this._itemPadding = this.panelWidth / 50;
  this._nextOriginX = this.panelWidth - 55;
  this._nextOriginY = 0;
  this._prevOriginX = -18;
  this._prevOriginY = 0;

  /**
   * Panel
   */

  game.slickUI.add(
    this.panel = new SlickUI.Element.DisplayObject(
      this._baseX, this._baseY, game.make.sprite(0,0, 'memory-bank'),
      this.panelWidth, this.panelHeight));
  this.panel.displayObject.width = this.panelWidth;
  this.panel.displayObject.height = this.panelHeight;

  // by default, not displayed
  this.panel.visible = false;
  this.panel.alpha = 0.8;

  /**
   * Toggle button
   */
  // until you click on the toggle button
  game.slickUI.add(
    this.toggleButton = new SlickUI.Element.DisplayObject(
      0,this._memoryPadding, game.make.button(0,0, 'memory-bank-button')));
  // set scale such that width = 1/8 panel width
  this.toggleButton.displayObject.scale.setTo(
    (this.panelWidth / 8) / this.toggleButton.displayObject.width);
  this.toggleButton.x = game.width - this._memoryPadding - this.toggleButton.displayObject.width;
  // show panel callback
  this.toggleButton.events.onInputDown.add(memoryBankButtonToggle, this);
  this.toggleButton.alpha = 0.9;

  /**
   * Text - name and description
   */
  var nameTextStyle = { font: '14px Goudy Bookletter 1911', fill: '#48f2ff', wordWrap: true, wordWrapWidth: this._memoryTextWidth, fontWeight: 'bold', boundsAlignH: 'center' };
  this.panel.add(
    this.nameText = new SlickUI.Element.DisplayObject(
      this._memoryTextOriginX,
      this._memoryTextOriginY,
      game.make.text(0,0, '', nameTextStyle), this._memoryTextWidth));
  // for alignment purposes
  var nameTextHeight = this.nameText.displayObject.getBounds().height;
  this.nameText.displayObject.setTextBounds(0,0, this._memoryTextWidth, nameTextHeight);

  var descTextStyle = { font: '14px Open Sans', fill: '#48f2ff', wordWrap: true, wordWrapWidth: this._memoryTextWidth, align: 'left' };
  this.panel.add(
    this.descText = new SlickUI.Element.DisplayObject(
      this._memoryTextOriginX,
      this._memoryTextOriginY + nameTextHeight,
      game.make.text(0,0, '', descTextStyle), this._memoryTextWidth));

  /**
   * Bookkeeping
   */
  // are we currently animating?
  this._isTweening = false;
  this._itemDisplayObjects = []; // for deletion purposes
  this._navButtons = [];
}

MemoryBankWindow.prototype = Object.create(Phaser.Group.prototype);
MemoryBankWindow.prototype.constructor = MemoryBankWindow;

MemoryBankWindow.prototype.display = function () {
  this.cleanWindow();
  this.displayItems();
  this.showNavButtons();
};

MemoryBankWindow.prototype.cleanWindow = function () {
  for (var i = 0; i < this._itemDisplayObjects.length; i++) {
    var item = this._itemDisplayObjects[i];
    item.container.displayGroup.removeAll(true);
    item.container.displayGroup.destroy();
  }
  for (i = 0; i < this._navButtons.length; i++) {
    var navButton = this._navButtons[i];
    navButton.container.displayGroup.removeAll(true);
    navButton.container.displayGroup.destroy();
  }
  this._itemDisplayObjects = [];
  this._navButtons = [];
};

MemoryBankWindow.prototype.displayItems = function () {
  var inventory = this._game.player.inventory;

  var itemEnd = this._itemStart + this._rowCapacity < inventory.length
    ? this._itemStart + this._rowCapacity
    : inventory.length;

  // Assumes InventoryItem objects in inventory.
  for (var i = this._itemStart; i < itemEnd; i++) {
    var itemId = inventory[i];

    // scaled width = 1/7 panel width;
    var desiredWidth = (this.panelWidth / 7);
    var itemIcon = new Icon(this._game, 0,0,
      itemId, 'memory-bank-icon-mask', 'memory-bank-icon' /* border */, desiredWidth);

    var slickItem;
    this.panel.add(slickItem = new SlickUI.Element.DisplayObject(
      this._itemOriginX + (i - this._itemStart)*(this._itemPadding + desiredWidth), this._itemOriginY,
      itemIcon));

    itemIcon.inputEnabled = true;
    itemIcon.input.useHandCursor = true;
    itemIcon.events.onInputOver.add(function () {
      this.nameText.displayObject.text = items[this.itemId]['name'].toUpperCase();
      this.descText.displayObject.text = items[this.itemId]['desc'];
    }, {nameText: this.nameText, descText: this.descText, itemId: itemId});

    this._itemDisplayObjects.push(slickItem);
  }
};

MemoryBankWindow.prototype.showNavButtons = function () {
  // next buttons
  if (this._itemStart + this._rowCapacity < this._game.player.inventory.length) {
    var nextButton = this._game.make.button(0,0,'memory-bank-next');
    var slickNext;
    this.panel.add(slickNext = new SlickUI.Element.DisplayObject(
      this._nextOriginX, this._nextOriginY, nextButton));
    // scaled by height, equal to panel height
    nextButton.scale.setTo(this.panelHeight / nextButton.height);
    this._navButtons.push(slickNext);

    nextButton.events.onInputUp.add(function () {
      this.switchRow(true);
      this.display();
    }, this);

  }

  // prev buttons
  if (this._itemStart > 0) {
    var prevButton = this._game.make.button(0,0,'memory-bank-next');
    // rotate sprite
    prevButton.anchor.setTo(0.5, 0.5);
    prevButton.scale.y *= -1;
    prevButton.anchor.setTo(1,1);

    var slickPrev;
    this.panel.add(slickPrev = new SlickUI.Element.DisplayObject(
      this._prevOriginX, this._prevOriginY,
      prevButton));
    this._navButtons.push(slickPrev);

    prevButton.scale.setTo(this.panelHeight / prevButton.height);

    prevButton.events.onInputUp.add(function () {
      this.switchRow(false);
      this.display();
    }, this);

  }
};

MemoryBankWindow.prototype.switchRow = function (wantsNextRow) {
  var inventory = this._game.player.inventory;
  if (wantsNextRow && this._itemStart + this._rowCapacity < inventory.length) {
    this._itemStart += this._rowCapacity;
    return;
  }
  if (!wantsNextRow && this._itemStart - this._rowCapacity >= 0) {
    this._itemStart -= this._rowCapacity;
    return;
  }
};

MemoryBankWindow.prototype.update = function () {
  // TODO: Stub.
};

},{"../../static/assets/items.json":32,"./Icon":12}],14:[function(require,module,exports){
/*
 * NPC
 * ====
 *
 * A sample prefab (extended game object class), displaying an NPC in a room.
 */

'use strict';

var npcs = require('../../static/assets/npcs.json');
var Toast = require('./Toast');

function NPC(game, x, y, id, height, width) {
  this.id = id;
  this.img = npcs[id]['image'];
  Phaser.Sprite.call(this, game, x, y, this.img);
  this.height = height;
  this.width = width;
  this.name = npcs[id]['name'];

  this._game = game;
  this.conv = npcs[id]['conv'];
  this.anchor.set(0.5);
  this.inputEnabled = true;
  this.input.useHandCursor = true;
  this.events.onInputDown.add(click, this);
  this.events.onInputOver.add(mouseover, this);
  this.events.onInputOut.add(mouseout, this);

  this.input.pixelPerfectOver = true;   // checks pixels so that collision only happens with non-transparent areas
                                        // computationally expensive, but maybe necessary for realism purposes?
}

NPC.prototype = Object.create(Phaser.Sprite.prototype);
module.exports = NPC.prototype.constructor = NPC;

function click() {
  this.hide();
  this._game.dialogueWindow.begin(this.conv);
}

function mouseover() {
  this._game.add.existing(this.toast = new Toast(this._game, this.name, 5));
}

function mouseout() {
  if (this.toast) {
    this.toast.toast.container.displayGroup.removeAll();
    this.toast.destroy();
  }
}

NPC.prototype.show = function() {
  var fadeInTween = this._game.add.tween(this);
  var fadeIn = 200;
  fadeInTween.to({alpha: 1}, fadeIn, Phaser.Easing.Linear.None, true);
  this.inputEnabled = true;
};

NPC.prototype.hide = function() {
  var fadeOutTween = this._game.add.tween(this);
  var fadeOut = 200;
  fadeOutTween.to({alpha: 0}, fadeOut, Phaser.Easing.Linear.None, true);
  this.inputEnabled = false;
};

},{"../../static/assets/npcs.json":33,"./Toast":21}],15:[function(require,module,exports){
/*
 * Placeable
 * ====
 *
 * A sample prefab (extended game object class), displaying an object in a room
 * (usually larger than a clickable) that can be clicked on to display a message,
 * but not added to the player's inventory.
 */

'use strict';

var Toast = require('./Toast');
var items = require('../../static/assets/items.json');

function Placeable(game, x, y, id, height, width) {
  Phaser.Sprite.call(this, game, x, y, id);
  this.height = height;
  this.width = width;

  this._game = game;
  this.id = id;
  this.name = items[id]['name'];
  this.message = items[id]['message'];
  this.anchor.set(0.5);
  this.inputEnabled = true;
  this.input.useHandCursor = true;
  this.events.onInputDown.add(click, this);
  this.events.onInputOver.add(mouseover, this);
  this.events.onInputOut.add(mouseout, this);

  this.input.pixelPerfectOver = true;   // checks pixels so that collision only happens with non-transparent areas
                                        // computationally expensive, but maybe necessary for realism purposes?
}

function click() {
  this._game.add.existing(new Toast(this._game, this.message, 5));
}

function mouseover() {
  this._game.add.existing(this.toast = new Toast(this._game, this.name, 5));
}

function mouseout() {
  if (this.toast) {
    this.toast.toast.container.displayGroup.removeAll();
    this.toast.destroy();
  }
}

Placeable.prototype = Object.create(Phaser.Sprite.prototype);
module.exports = Placeable.prototype.constructor = Placeable;
},{"../../static/assets/items.json":32,"./Toast":21}],16:[function(require,module,exports){
/*
* Player
* ====
*
* The player object class.
*/

'use strict';

function Player(game) {
  Phaser.Group.call(this, game);
  this.inventory = [];
  this.memoryBank = [];
  this.seenAreas = []; //areas seen to track what can go in area transition window
  this.variables = {};
  this.currentRoom = null;
  this.convoIdx = 0;
  this.shownConvo = [];
  this.convoFile = null;

}

Player.prototype = Object.create(Phaser.Group.prototype);
module.exports = Player.prototype.constructor = Player;

Player.prototype.serialize = function(game){
  var fields = [
    'inventory',
    'memoryBank',
    'seenAreas',
    'variables'
  ];

  var obj = {};

  for (let i in fields){
    let field = fields[i];
    obj[field] = this[field];
  }
  //since the room info contains all the objects in room, can I pop off there?
  obj['currentRoom'] = game.room.area;
  obj['convoIdx'] = game.dialogueWindow.convoManager.idx;
  obj['shownConvo'] = game.dialogueWindow.convoManager.shown;
  //since the convoFile is not stored in the game, we will just store it with the
  //player whenever a new file is started.
  //or we could store that also in the Dialogue manager??
  obj['convoFile'] = game.dialogueWindow.convoFile;
  return JSON.stringify(obj);
};

Player.unserialize = function(playerState, game){

  if (typeof playerState === 'string'){
    playerState = JSON.parse(playerState, (key, value) => {
      return value;     // return the unchanged property value.
    });
  }

  game.player = game.add.existing(new Player(game));

  for (let field in playerState){
    game.player[field] = playerState[field];
  }

};

},{}],17:[function(require,module,exports){
/*
 * Room
 * ====
 *
 * A sample prefab (extended game object class), displaying a room background.
 */

'use strict';

var Clickable = require('../objects/Clickable');
var Placeable = require('../objects/Placeable');
var NPC = require('../objects/NPC');
var areas = require('../../static/assets/areas.json');

function Room(game, room) {
  this._game = game;
  this.name = room;

  this.area = areas[room];
  this.items = [];
  this.placeables = [];
  this.npcs = [];//how does this interact with the conversation manager?
  //this is causing the glitch where the room blinks on load
  //though even a new game blinks
  Phaser.Sprite.call(this, game, game.world.centerX, game.world.centerY, this.area['bg']);
  this.anchor.set(0.5);

}

Room.prototype = Object.create(Phaser.Sprite.prototype);
module.exports = Room.prototype.constructor = Room;

Room.prototype.addItems = function() {
  //would prefer this in load areas TODO restructure
  if (typeof this._game.music !== 'undefined' && this._game.music !== null)
    this._game.music.fadeOut(1000); // fade out previous music
  this._game.music = this._game.sound.play(this.area.music);
  this._game.music.loopFull(1);

  for (var i = 0; i < this.area['items'].length; i++) {
    var item = this.area['items'][i];
    this._game.add.existing(item = new Clickable(this._game, item['x'], item['y'], item['id'], item['height'], item['width']));
    this.items.push(item);
  }
  for (i = 0; i < this.area['placeables'].length; i++) {
    var placeable = this.area['placeables'][i];
    this._game.add.existing(placeable = new Placeable(this._game, placeable['x'], placeable['y'], placeable['id'], placeable['height'], placeable['width']));
    this.placeables.push(placeable);
  }
  for (i = 0; i < this.area['npcs'].length; i++) {
    var npc = this.area['npcs'][i];

    var showNPC = true;       // check to see if NPC meets conditions to be shown in this area
    if ('showif' in npc) {
      for (var condition in npc['showif']) {
        if (this._game.player.variables[condition] != npc['showif'][condition]) {
          showNPC = false;
        }
      }
    }
    if (!showNPC) {
      continue; // if NPC doesn't meet conditions to be shown, skip them
    }
    this._game.add.existing(npc = new NPC(this._game, npc['x'], npc['y'], npc['id'], npc['height'], npc['width']));
    if (npc.conv === this._game.player.convoFile){
      npc.alpha = 0;
    }
    // if we want to re-enter a room and talk to a character again
    // then we don't want to pop them off of the stack
    this.npcs.push(npc);
  }
  this._game.world.bringToTop(this._game.slickUI.container.displayGroup);
};

Room.prototype.clearItems = function() {
  for (var i = 0; i < this.items.length; i++) {
    this.items[i].destroy();
  }
  for (i = 0; i < this.placeables.length; i++) {
    this.placeables[i].destroy();
  }
  for (i = 0; i < this.npcs.length; i++) {
    this.npcs[i].destroy();
  }
  this.items = [];
  this.placeables = [];
  this.npcs = [];
};

Room.prototype.loadArea = function(area) {
  this.area = areas[area];

  //below should track areas seen so that when area transition is pressed
  //it will update with what the specific player has access to.
  if (!this._game.player.seenAreas.includes(area)){
    this._game.player.seenAreas.push(area);
  }
  this.name = area;
  this._game.camera.fade('#000000', 2000);
  this._game.camera.onFadeComplete.addOnce(function() {
    this.clearItems();
    this._game.camera.flash('#000000', 2000);
    this.loadTexture(this.area['bg']);
    this.addItems();
  }, this);
};

},{"../../static/assets/areas.json":31,"../objects/Clickable":8,"../objects/NPC":14,"../objects/Placeable":15}],18:[function(require,module,exports){
/*
 * SaveButton
 * ====
 * Save button, flush player Object to local store.
 *
 */

'use strict';

var Toast = require('./Toast');

function SaveButton(game) {
  Phaser.Sprite.call(this, game, 20, 20, 'saveButton');
  this.height = 30;
  this.width = 50;

  this._game = game;
  this.id = 'saveButton';
  this.name = 'Save Button';
  this.anchor.set(0.5);
  this.alpha = 0.5;
  this.inputEnabled = true;
  this.input.useHandCursor = true;
  this.events.onInputDown.add(click, this);
  this.events.onInputOver.add(mouseover, this);
  this.events.onInputOut.add(mouseout, this);
}

function click() {
  this._game.sound.play('save-notification');
  this._game.add.existing(new Toast(this._game, 'Game Saved!', 5));
  this._game.dialogueWindow.display(true); // refresh dialogue display
  var saveString = this._game.player.serialize(this._game);
  localStorage.setItem('playerState', saveString);
}

function mouseover() {
  this.alpha = 1;
  this._game.add.existing(this.toast = new Toast(this._game, this.name, 5));
}

function mouseout() {
  if (this.toast) {
    this.toast.toast.container.displayGroup.removeAll();
    this.toast.destroy();
  }
}

SaveButton.prototype = Object.create(Phaser.Sprite.prototype);
module.exports = SaveButton.prototype.constructor = SaveButton;

},{"./Toast":21}],19:[function(require,module,exports){
/*
 * Scrollbar
 * =========
 *
 * Bitmap scrollbar that follows a set of given points.
 */

'use strict';

module.exports = Scrollbar;

function Scrollbar(game, x, y, uiParent, points, maxScroll, lineWidth = 2, scrollbarWidth = 6) {
  Phaser.Group.call(this, game/*, ...args*/);

  this._game = game;
  // Dispatch signals; others may attach events to these signals
  this.onDragStart = new Phaser.Signal();
  this.onDrag = new Phaser.Signal();
  this.onDragStop = new Phaser.Signal();
  this.onSetValue = new Phaser.Signal();

  // Initial value
  this._value = 0;
  // How wide is our scrollbar?
  this._scrollbarWidth = scrollbarWidth;
  // How many pixels down can we scroll?
  this._maxScroll = maxScroll;
  // Determines path of scrollbar, as well as bounds
  this.points = points;

  // Draw bitmap path
  this.maxWidth = Math.max(...this.points.x);
  this.maxHeight = Math.max(...this.points.y);

  var bmdPath = this._game.make.bitmapData(this.maxWidth + lineWidth, this.maxHeight + lineWidth);
  var interpInc = 1 / this.maxHeight;
  for (var i = 0; i < 1; i += interpInc) {
    var px = this._game.math.linearInterpolation(this.points.x, i);
    var py = this._game.math.linearInterpolation(this.points.y, i);
    bmdPath.rect(px, py, lineWidth, lineWidth, '#48f2ff');
  }

  this.scrollbarLine = new SlickUI.Element.DisplayObject(
    x, y, this._game.make.sprite(0,0, bmdPath));

  // Draw scrollbar
  this._scrollbarRatio = (this.maxHeight + this._scrollbarWidth - this._maxScroll) / this.maxHeight;

  // Bitmap data for scrollbar
  this._bmdScroll = this._game.make.bitmapData(
    this.maxWidth + this._scrollbarWidth, 
    this.maxHeight + this._scrollbarWidth);

  for (i = 0; i < this._scrollbarRatio; i += interpInc) {
    px = this._game.math.linearInterpolation(points.x, i);
    py = this._game.math.linearInterpolation(points.y, i);
    this._bmdScroll.rect(px, py, this._scrollbarWidth, this._scrollbarWidth, '#48f2ff');
  }
  var scrollbarSprite = this._game.make.sprite(0,0, this._bmdScroll);
  this.scrollbar = new SlickUI.Element.DisplayObject(
    x-this._scrollbarWidth/2, 
    y-this._scrollbarWidth/2, 
    scrollbarSprite);

  // Display events
  scrollbarSprite.inputEnabled = true;
  scrollbarSprite.input.useHandCursor = true;
  
  // Handle mouse input
  scrollbarSprite.events.onInputDown.add(function (sprite, pointer) {
    this._dragging = true;
    this._dragPoint = pointer.y;
    this._dragValue = this._value;

    this.onDragStart.dispatch(this._value);
  }, this);
  scrollbarSprite.events.onInputUp.add(function () {
    this._dragging = false;

    this.onDragStop.dispatch(this._value);
  }, this);

  this._game.input.addMoveCallback(function (pointer, pointerX, pointerY) {
    if (!this._dragging)
      return;

    // Measure scroll relative to dragPoint
    var start = this._dragPoint - this._dragValue*this._maxScroll;
    var clampedDelta = Math.min(Math.max(0, pointerY - start), this._maxScroll);

    // Update value
    this._value = (1/this._maxScroll)*clampedDelta;

    // Redraw bitmap to update sprite
    this.redraw();

    this.onDrag.dispatch(this._value);
    
  }, this);

  // Add to SlickUI parent
  uiParent.add(this.scrollbarLine);
  uiParent.add(this.scrollbar);
  
}
Scrollbar.prototype = Object.create(Phaser.Group.prototype);
Scrollbar.prototype.constructor = Scrollbar;

Scrollbar.prototype.redraw = function () {
  this._bmdScroll.clear();
  // Redraw bitmap to update sprite
  var startBitmap = this._value*this._maxScroll / this.maxHeight;
  var interpInc = 1/this.maxHeight;
  for (var i = startBitmap; i < startBitmap + this._scrollbarRatio; i += interpInc) {
    var px = this._game.math.linearInterpolation(this.points.x, i);
    var py = this._game.math.linearInterpolation(this.points.y, i);
    this._bmdScroll.rect(px, py, this._scrollbarWidth, this._scrollbarWidth, '#48f2ff');
  }
};

Scrollbar.prototype.destroy = function () {
  // if display container exists (i.e. not destroyed)
  if (typeof this.scrollbarLine.container !== 'undefined' && this.scrollbarLine.container !== null) {
    this.scrollbarLine.container.displayGroup.removeAll(true);
    this.scrollbarLine.container.displayGroup.destroy();
    this.scrollbarLine.container = undefined;
  }
  
  if (typeof this.scrollbar.container !== 'undefined' && this.scrollbar.container !== null) {
    this.scrollbar.container.displayGroup.removeAll(true);
    this.scrollbar.container.displayGroup.destroy();
    this.scrollbar.container = undefined;
  }
  this.scrollbarLine.sprite = undefined;
  this.scrollbar.sprite = undefined;
};

Scrollbar.prototype.update = function () {
  // TODO: Stub.
};

/** Explicitly define setters and getters */
// value
Object.defineProperty(Scrollbar.prototype, 'value', {
  get: function () {
    return this._value;
  },
  set: function (value) {
    this._value = Math.min(Math.max(0, value), 1);
    this.redraw();
    this.onSetValue.dispatch(this._value);
  }
});

},{}],20:[function(require,module,exports){
'use strict';

var Card = require('./Card');
var tactics = require('../../static/assets/tactics.json');

function Tactic(game, x, y, assetName, multiUse = false) {
  Card.call(this, game, x, y, assetName, multiUse);
}

Tactic.prototype = Object.create(Card.prototype);
module.exports = Tactic.prototype.constructor = Tactic;

/* BEGIN OVERRIDE FUNCTIONS */
Tactic.prototype.getName = function () {
  return tactics[this.key]['name'];
};

Tactic.prototype.getDescription = function () {
  return tactics[this.key]['desc'];
};
/* END OVERRIDE FUNCTIONS */
},{"../../static/assets/tactics.json":34,"./Card":7}],21:[function(require,module,exports){
/*
 * Toast
 * ====
 *
 * A sample prefab (extended game object class), displaying a toast (popup at top of game screen) that displays
 * text and disappears after several seconds.
 */

'use strict';

var textstyles = require('../../static/assets/textstyles.json');

function Toast(game, message, timeout) {
  Phaser.Group.call(this, game);

  this._game = game;
  this.message = message;
  this.timeout = timeout;

  if (game.toast) {
    game.toast.toast.container.displayGroup.removeAll();
    game.toast.destroy();
  }

  // private members specifying margin and padding
  this.toastTextY = 16;

  this.toastHeight = game.height * 1/12;
  this.toastWidth = game.width * 1/2;

  this.toastX = game.width * 1/2 - this.toastWidth * 1/2;
  this.toastY = 8;

  game.slickUI.add(this.toast = new SlickUI.Element.DisplayObject(
    this.toastX, this.toastY, game.make.sprite(0, 0, 'toast'),
    this.toastWidth, this.toastHeight));
  this.toast.displayObject.width = this.toastWidth;
  this.toast.displayObject.height = this.toastHeight;

  game.toast = this;

  this.toast.add(
    this.toastText = new SlickUI.Element.DisplayObject(0, 0, 
      game.make.text(0, this.toastTextY, message, textstyles['toast']))
  );
  this.toastText.displayObject.setTextBounds(0, this.toastTextY, this.toastWidth, this.toastHeight);

  this.toast.alpha = 0.8;

  game.time.events.add(Phaser.Timer.SECOND * timeout, destroyPopup, this);
}

function destroyPopup() {
  this.toast.container.displayGroup.removeAll();
  this.destroy();
}

Toast.prototype = Object.create(Phaser.Group.prototype);
module.exports = Toast.prototype.constructor = Toast;
},{"../../static/assets/textstyles.json":35}],22:[function(require,module,exports){
'use strict';

var Card = require('../objects/Card');
var Tactic = require('../objects/Tactic');
var Argument = require('../objects/Argument');
var items = require('../../static/assets/items.json');
var Player = require('../objects/Player');
var Room = require('../objects/Room');

var BattleUi = require('../objects/BattleUi.js');
var ArgumentManager = require('../objects/ArgumentManager');
var DialogueWindow = require('../objects/DialogueWindow');
var CustomActions = require('../utils/CustomActions');

exports.preload = function(game) {
  // preload all UI menu themes.
  game.slickUI.load('ui/kenney-theme/kenney.json');
};

exports.create = function (game) {
  if (game.player === null || typeof game.player === 'undefined') {
    game.player = game.add.existing(new Player(game));
    // DUMMY DATA
    game.player.inventory.push('listener');
    game.player.inventory.push('note');
    game.room = (new Room(game, 'hangar'));
    // END DUMMY DATA
  }
  // Companions
  game.companions = ['Mysterious Voice', 'Kismet'];  // DUMMY DATA

  // Music
  if (typeof game.music !== 'undefined' && game.music !== null)
    game.music.fadeOut(1000); // fade out previous music

  game.argumentManager = new ArgumentManager(game);
  var customActions = new CustomActions(game);
  game.argumentManager = new ArgumentManager(game, customActions);

  game.argumentManager.loadJSONConversation('battle01');
  game.currentArgument = 0;
  game.playerTurn = true;
  game.cred = 4;
  game.persuasion = 5;
  game.turnCount = 0;

  // adding in player cards and face
  game.playerDeck = [];
  for (var i = 0; i < game.player.inventory.length; i++) {
    game.playerDeck.push(new Card(game, 0,0, items[game.player.inventory[i]]['id']));
  }

  // adding opponent face and opponent cards --to do: fetch these from main game state
  game.opponentDeck = [];
  game.args = game.argumentManager.getAllArguments();
  for (i = 0; i < game.args.length; i++) {
    // TODO: support for multiple counters
    if ('bluff' in game.args[i] && game.args[i]['bluff'] === true) {
      // do not include bluffs
      continue;
    }
    if (game.args[i]['counters'].length <= 0)
      continue;
    game.opponentDeck.push(new Argument(game, 0,0, game.args[i]['id'], game.args[i]['counters'][0], i));
  }

  game.battleUi = new BattleUi(game, game.playerDeck, game.opponentDeck);
  game.battleUi.cardSignal.add(cardAction, this);
  game.battleUi.companionSignal.add(companionText, this);

  game.dialogueWindow = new DialogueWindow(game, game.argumentManager);
  startLogicBattle(game);
};

function startLogicBattle(game) {
  // Load JSON
  game.dialogueWindow.loadJSONConversation('battle01');

  // Play intro sequence and display
  game.argumentManager.startSpecialArgument('intro');
  game.dialogueWindow.display();

  // Disable and then reenable input
  game.battleUi.cardsInputEnabled(false);
  game.argumentManager.specialCompleteSignal.add(function () {
    /* Fun intro display stuff */
    // Display overlay and intro text
    var introTween = game.battleUi.introTweens();
    introTween.onComplete.add(function () {
      game.battleUi.battleStart();  // enable cards and reveal current arg
      game.dialogueWindow.display();
   
      // Start music
      game.music = game.sound.play('off-limits');
      game.music.fadeIn(1000);
      game.music.loopFull(1);
    });

    game.argumentManager.specialCompleteSignal.removeAll();
  });

  game.turnCount = 1;
}

function cardAction(game, card) {
  if (game.playerTurn) {
    game.dialogueWindow.skipText();

    game.playerTurn = false;
    game.battleUi.cardsInputEnabled(false);

    var argument = game.opponentDeck[game.currentArgument];

    var isCorrect = card.key === argument.key;

    if (isCorrect) {

      game.battleUi.playCardAnimation(card, argument, true);
      game.opponentDeck[game.currentArgument] = undefined;
      argument.destroy();
      if (!card.multiUse) {
        card.destroy();
      }
        
    } else {
      game.battleUi.playCardAnimation(card, argument, false);

    }

    var textType = isCorrect ? 'correct' : 'incorrect';

    game.battleUi.cardAnimCompleteSignal.add(argumentInterlude, this, game, textType);
  }
}

function companionText(game, speaker) {
  if (game.playerTurn) {
    game.dialogueWindow.skipText();
    game.battleUi.cardsInputEnabled(false);

    game.argumentManager.startInterlude(speaker);
    game.dialogueWindow.display();

    game.argumentManager.interludeCompleteSignal.add(function () {
      game.battleUi.cardsInputEnabled(true);
      game.dialogueWindow.display();
      game.argumentManager.interludeCompleteSignal.removeAll();
    });
  }
}

function argumentInterlude(game, type) {
  game.argumentManager.startInterlude(type);
  game.dialogueWindow.display();
  game.argumentManager.interludeCompleteSignal.add(function () {
    opponentTurn(game);
    game.argumentManager.interludeCompleteSignal.removeAll();
  });

  game.battleUi.cardAnimCompleteSignal.removeAll();
}

function gleamingShoalBluff(game) {
  game.argumentManager.startSpecialArgument('ability', 'bluff');
  game.dialogueWindow.display();

  // special bluff. hard-coded.
  var lastArgument = game.opponentDeck.pop();
  for (var i = 0; i < game.args.length; i++) {
    if ('bluff' in game.args[i] && game.args[i]['bluff'] === true) {
      // TODO: use Mersenne-Twister for more randomness
      var randPosition = Math.random();
      var newBluff = new Argument(game, 0,0, game.args[i]['id'], game.args[i]['counters'][0], i);
      if (randPosition > 0.5) {
        game.opponentDeck.unshift(newBluff);
      } else {
        game.opponentDeck.push(newBluff);
      }
    }
  }
  // add last argument to the end.
  game.opponentDeck.push(lastArgument);
}

function giveCallBluffTactic(game) {
  // Give player a special Call Bluff tactic.
  var callBluff = new Tactic(game, 0, 0, 'call-bluff', true /* multiUse */);
  game.playerDeck.push(callBluff);
  game.battleUi.makeCardIcon(callBluff);
}

/** TODO: HARDCODED SPECIAL ACTIONS = AWFUL */
function checkSpecialActions(game) {
  return game.turnCount === 2;
}
function specialActions(game) {
  if (game.turnCount === 2) {
    // on the second turn, bluff
    gleamingShoalBluff(game); // adds arguments into model
    // when we finish the ability text...
    game.argumentManager.specialCompleteSignal.add(function () {
      // shuffle
      var rouletteTween = game.battleUi.rouletteArguments();
      rouletteTween.onComplete.add(function () {
        // add arguments into ui view
        updateCurrentArgument(game);
        game.battleUi.updateArguments(game.opponentDeck, game.currentArgument);
        game.battleUi.positionArguments(game);
        game.battleUi.argAnimCompleteSignal.add(function () {
          finishOpponentTurn(game);
          giveCallBluffTactic(game);
          game.battleUi.argAnimCompleteSignal.removeAll();
        });
      }, this);
      game.argumentManager.specialCompleteSignal.removeAll();
    });
    
    return true;
  }
  // TODO: randomly entrench or shuffle
  if (game.turnCount > 2) {
    // do nothing for now.
    return false;
  }
}

function opponentTurn(game) {
  game.turnCount++;

  if (game.opponentDeck[game.currentArgument] === undefined) {
    game.persuasion -= 1;
    game.battleUi.updatePersuasionBar();    
  } else if (game.opponentDeck[game.currentArgument]) {

    game.cred -= 1;
    game.battleUi.updateCredBar(game.cred, true); // update cred bar with damage indication
  } else {
    game.persuasion -= 1;
    game.battleUi.updatePersuasionBar();
  }

  updateCurrentArgument(game);
  game.battleUi.updateArguments(game.opponentDeck, game.currentArgument);
  game.battleUi.positionArguments(game, true);
  // Display arguments on animation completion
  game.battleUi.argAnimCompleteSignal.add(function () {
    var hasSpecialAction = checkSpecialActions(game);
    if (hasSpecialAction) {
      game.battleUi.argAnimCompleteSignal.removeAll();
      specialActions(game);
      return;
    }
    finishOpponentTurn(game);
    game.battleUi.argAnimCompleteSignal.removeAll();
  }, this);

}

function finishOpponentTurn(game) {
  // upon finishing argument positioning
  // reveal current argument
  game.battleUi.revealCurrent();

  // reenable player input and start player turn
  updateArgumentWindow(game);
  game.battleUi.positionCards();
  game.battleUi.cardsInputEnabled(true);
  game.playerTurn = true;
}

// For ArgumentManager
function currentArgumentJsonIdx(game) {
  var currentArgument = game.opponentDeck[game.currentArgument];
  if (!currentArgument)
    return -1;
  return currentArgument.jsonIdx;
}

function updateArgumentWindow(game) {
  game.argumentManager.advanceToTarget(currentArgumentJsonIdx(game));
  if(game.cred === 0) {
    game.argumentManager.startSpecialArgument('lose');
  }
  if(game.persuasion === 0) {
    game.argumentManager.startSpecialArgument('win');
  }
  game.dialogueWindow.display();
}

function updateCurrentArgument(game) {
  game.currentArgument += 1;

  for (var i = 0; i < game.opponentDeck.length; i++) {
    var idx = game.currentArgument + i;
    if (idx >= game.opponentDeck.length)
      idx -= game.opponentDeck.length;
    // if exists
    if (typeof game.opponentDeck[idx] !== 'undefined' && game.opponentDeck[idx] !== null) {
      game.currentArgument = idx;
      return;
    }
  }
  // exiting means we have no more arguments
}

},{"../../static/assets/items.json":32,"../objects/Argument":4,"../objects/ArgumentManager":5,"../objects/BattleUi.js":6,"../objects/Card":7,"../objects/DialogueWindow":10,"../objects/Player":16,"../objects/Room":17,"../objects/Tactic":20,"../utils/CustomActions":30}],23:[function(require,module,exports){
/*
 * Boot state
 * ==========
 *
 * The first state of the game, responsible for setting up some Phaser
 * features. Adjust the game appearance, number of input pointers, screen
 * orientation handling etc. using this game state.
 */

'use strict';

var assets = require('../assets');

exports.preload = function (game) {
  // Point the Phaser Asset Loader to where your game assets live.
  game.load.path = 'assets/';

  // Initialize physics engines here. Remember that Phaser builds including
  // Arcade Physics have it enabled by default.
  //game.physics.startSystem(Phaser.Physics.P2);

  // Adjust how many pointers Phaser will check for input events.
  game.input.maxPointers = 2;

  // Set the alignment of the game canvas within the page.
  game.scale.pageAlignHorizontally = true;

  // Adjust the scaling mode of the game canvas.
  // Example: If you're developing a pixel-art game, set it to 'USER_SCALE'.
  game.scale.scaleMode = Phaser.ScaleManager.NO_SCALE;

  // When using 'USER_SCALE' scaling mode, use this method to adjust the
  // scaling factor.
  //game.scale.setUserScale(2);

  // Uncomment the following line to adjust the rendering of the canvas to
  // crisp graphics. Great for pixel-art!
  //Phaser.Canvas.setImageRenderingCrisp(game.canvas);

  // Uncomment this line to disable smoothing of textures.
  //game.stage.smoothed = false;

  // If the game canvas loses focus, keep the game loop running.
  game.stage.disableVisibilityChange = true;

  // Whether to use frame-based interpolations or not.
  game.tweens.frameBased = false;

  // Load the graphical assets required to show the splash screen later,
  // using the asset pack data.
  game.load.pack('boot', null, assets);
};

exports.create = function (game) {
  // After applying the first adjustments and loading the splash screen
  // assets, move to the next game state.
  game.state.start('Preloader');
};

},{"../assets":2}],24:[function(require,module,exports){
/*
* Credits state
* =============
*
* The player should be able to return to the main menu.
*
*/

'use strict';

exports.init = function() {
  this.description = 'Congratulations! You\'ve reached the end of our playable demo. \
  We hope you enjoyed the first chapter of Quasaria as much as we enjoyed making it!';
  this.credits = 'Developed by:\nAlexandros Christodoulou-Rubalcava\nHana Lee\nAmber Thomas\nEdward Wang';
};

exports.create = function (game) {
  this.camera.flash('#000000', 2000);

  //might not be in quotes, its an issue below
  var screen = game.add.sprite(game.world.centerX, game.world.centerY, 'menu_screen');
  screen.anchor.setTo(0.5, 0.5);

  let screenFont = 'Cinzel Decorative';
  let fillColor = '#42dff4';

  var descText = game.add.text(game.world.centerX, game.world.centerY - 100, this.description, {
    font: '16px ' + screenFont,
    fill: fillColor,
    align: 'center',
    wordWrap: true,
    wordWrapWidth: game.width - 300
  });

  var creditsText = game.add.text(game.world.centerX, game.world.centerY + 120, this.credits, {
    font: '16px ' + screenFont,
    fill: fillColor,
    align: 'center',
    wordWrap: true,
    wordWrapWidth: game.width - 300
  });

  var mainMenuText = game.add.text(game.world.centerX, game.world.centerY, 'Main Menu', {
    font: '50px ' + screenFont,
    fill: fillColor,
    align: 'center'
  });

  descText.anchor.setTo(0.5, 0.5);
  creditsText.anchor.setTo(0.5, 0.5);

  mainMenuText.anchor.setTo(0.5, 0.5);
  mainMenuText.inputEnabled = true;
  mainMenuText.events.onInputOver.add(function() {
    mainMenuText.fill = '#ff00ff';
  }, this);

  mainMenuText.events.onInputOut.add(function() {
    mainMenuText.fill = '#42dff4';
  }, this);

  mainMenuText.events.onInputDown.add(function () {
    game.state.start('MainMenu');
  }, this);

};

},{}],25:[function(require,module,exports){
/*
* Game state
* ==========
*
* A sample Game state, displaying the Phaser logo.
*/

'use strict';

var Room = require('../objects/Room');
var Player = require('../objects/Player');
var DialogueWindow = require('../objects/DialogueWindow');
var ConversationManager = require('../objects/ConversationManager');
var CustomActions = require('../utils/CustomActions');
var MemoryBankWindow = require('../objects/MemoryBankWindow');
var AreaTransitionWindow = require('../objects/AreaTransitionWindow');
var SaveButton = require('../objects/SaveButton');

exports.preload = function(game) {
  // preload all UI menu themes.
  game.slickUI.load('ui/kenney-theme/kenney.json');
};

exports.init = function(game, resumeGame, fromBattle){

  let playerState = localStorage.getItem('playerState');
  if (fromBattle) {
    game.room = new Room(game, 'hangar');  
  } else if (resumeGame && playerState !== null){
    Player.unserialize(playerState, game);
    //current room is actually room.area
    //need to deep copy, otherwise we will loose the area info
    var area = JSON.parse(JSON.stringify(game.player.currentRoom));
    game.room = (new Room(game, area.id));
    game.room.area = area;

  } else { //check if old model blinks
    localStorage.clear();
    game.player = (new Player(game));
    // game.player.variables['debug'] = 'true';    // comment this out to get rid of DEBUG - SKIP TO END conversation options
    game.player.convoFile = 'prologue01';
    game.room = (new Room(game, 'shuttle'));

  }

};

exports.create = function (game) {

  this.camera.flash('#000000', 2000);
  game.add.existing(game.player);

  game.add.existing(game.room);
  game.room.addItems();


  // we previously had music in the game state, but I move it to the room object
  // so that we can have different themes for different rooms
  // need to set the music in the other states like logic battles

  game.add.existing(new SaveButton(game));

  // custom actions for conversations
  var customActions = new CustomActions(game);
  // conversation manager
  var convoManager = new ConversationManager(game, customActions);
  convoManager.idx = game.player.convoIdx;
  convoManager.shown = game.player.shownConvo;

  // dialogue window object
  game.dialogueWindow = new DialogueWindow(game, convoManager);
  // memory bank window object
  game.memoryBankWindow = new MemoryBankWindow(game);
  // area transition window object
  game.areaTransitionWindow = new AreaTransitionWindow(game);

  game.dialogueWindow.begin(game.player.convoFile);

};

},{"../objects/AreaTransitionWindow":3,"../objects/ConversationManager":9,"../objects/DialogueWindow":10,"../objects/MemoryBankWindow":13,"../objects/Player":16,"../objects/Room":17,"../objects/SaveButton":18,"../utils/CustomActions":30}],26:[function(require,module,exports){
/*
* Game Over state
* ===============
*
* The player should be able to restart a saved game or return to the main menu..
*
*/

'use strict';

exports.init = function(game, gameOverText) {
  this.gameOverText = gameOverText;
};

exports.create = function (game) {
  this.camera.flash('#000000', 2000);

  if (typeof game.music !== 'undefined' && game.music !== null)
    game.music.fadeOut(1000); // fade out previous music
  game.music = game.sound.play('cold-moon');
  game.music.loopFull(1);
  //might not be in quotes, its an issue below
  var screen = game.add.sprite(game.world.centerX, game.world.centerY, 'menu_screen');
  screen.anchor.setTo(0.5, 0.5);

  let screenFont = 'Cinzel Decorative';
  let fillColor = '#42dff4';

  var titleText = game.add.text(game.world.centerX, game.world.centerY- 85, 'Game Over', {
    font: '75px ' + screenFont,
    fontWeight: 'bold',
    fill: fillColor,
    align: 'center'
  });

  var descText = game.add.text(game.world.centerX, game.world.centerY - 20, this.gameOverText, {
    font: '25px ' + screenFont,
    fill: fillColor,
    align: 'center'
  });

  var contText = game.add.text(game.world.centerX, game.world.centerY + 30, 'Reload', {
    font: '50px ' + screenFont,
    fill: fillColor,
    align: 'center'
  });

  var mainMenuText = game.add.text(game.world.centerX, game.world.centerY + 85, 'Main Menu', {
    font: '50px ' + screenFont,
    fill: fillColor,
    align: 'center'
  });

  titleText.anchor.setTo(0.5, 0.5);

  descText.anchor.setTo(0.5, 0.5);

  contText.anchor.setTo(0.5, 0.5);
  contText.inputEnabled = true;
  contText.events.onInputOver.add(function() {
    contText.fill = '#ff00ff';
  }, this);

  contText.events.onInputOut.add(function() {
    contText.fill = '#42dff4';
  }, this);

  contText.events.onInputDown.add(function () {
    let resumeGame = true;
    game.state.start('Game', true, false, game, resumeGame);
  }, this);

  mainMenuText.anchor.setTo(0.5, 0.5);
  mainMenuText.inputEnabled = true;
  mainMenuText.events.onInputOver.add(function() {
    mainMenuText.fill = '#ff00ff';
  }, this);

  mainMenuText.events.onInputOut.add(function() {
    mainMenuText.fill = '#42dff4';
  }, this);

  mainMenuText.events.onInputDown.add(function () {
    game.state.start('MainMenu');
  }, this);

};

},{}],27:[function(require,module,exports){
/*
* Main Menu state
* ===============
*
* The player should be able to restart a saved game or start a new game.
*
*/

'use strict';

exports.create = function (game) {

  //might not be in quotes, its an issue below
  game.music = game.sound.play('menu-theme-terraform');
  game.music.loopFull(1);

  var screen = game.add.sprite(game.world.centerX, game.world.centerY, 'menu_screen');
  screen.anchor.setTo(0.5, 0.5);

  var logo = game.add.sprite(game.world.centerX, game.world.centerY - 30, 'quasaria-logo-MM');
  logo.anchor.setTo(0.5, 0.5);
  logo.alpha = .1;

  let screenFont = 'Cinzel Decorative';
  let fillColor = '#42dff4';

  var titleText = game.add.text(game.world.centerX, game.world.centerY- 75, 'Quasaria', {
    font: '75px ' + screenFont,
    fontWeight: 'bold',
    fill: fillColor,
    align: 'center'
  });

  var contText = game.add.text(game.world.centerX, game.world.centerY, 'Continue', {
    font: '50px ' + screenFont,
    fill: fillColor,
    align: 'center'
  });

  var newGameText = game.add.text(game.world.centerX, game.world.centerY + 55, 'New Game', {
    font: '50px ' + screenFont,
    fill: fillColor,
    align: 'center'
  });

  titleText.anchor.setTo(0.5, 0.5);


  contText.anchor.setTo(0.5, 0.5);
  contText.inputEnabled = true;
  contText.events.onInputOver.add(function() {
    contText.fill = '#ff00ff';
  }, this);

  contText.events.onInputOut.add(function() {
    contText.fill = '#42dff4';
  }, this);

  contText.events.onInputDown.add(function () {
    let resumeGame = true;
    game.state.start('Game', true, false, game, resumeGame);
  }, this);

  newGameText.anchor.setTo(0.5, 0.5);
  newGameText.inputEnabled = true;
  newGameText.events.onInputOver.add(function() {
    newGameText.fill = '#ff00ff';
  }, this);

  newGameText.events.onInputOut.add(function() {
    newGameText.fill = '#42dff4';
  }, this);

  newGameText.events.onInputDown.add(function () {
    let resumeGame = false;
    game.state.start('Game', true, false, game, resumeGame);
  }, this);

};

},{}],28:[function(require,module,exports){
/*
 * Preloader state
 * ===============
 *
 * Takes care of loading the main game assets, including graphics and sound
 * effects, while displaying a busy splash screen.
 */

'use strict';

var assets = require('../assets');


function showSplashScreen (game) {
  game.add.image(0, 0, 'splash-screen');
  game.load.setPreloadSprite(game.add.image(82, 282, 'progress-bar'));
}

exports.preload = function (game) {
  showSplashScreen(game);
  game.load.pack('game', null, assets);
  game.load.pack('main_menu', null, assets);
  game.load.pack('ui', null, assets);
  game.load.pack('conversations', null, assets);
  game.load.pack('sounds', null, assets);
  game.load.pack('logic_battle', null, assets);
};

exports.create = function (game) {
  // Here is a good place to initialize plugins dependent of any game asset.
  // Don't forget to `require` them first. Example:
  //game.myPlugin = game.plugins.add(MyPlugin/*, ... parameters ... */);

  // Slick UI initialization; added from index.html
  // NOTE: slick UI loads theme from cache
  // between preload and create functions FOR EACH STATE
  game.slickUI = game.plugins.add(Phaser.Plugin.SlickUI);

  game.state.start('MainMenu');

};

},{"../assets":2}],29:[function(require,module,exports){
/*
 * `states` module
 * ===============
 *
 * Declares all present game states.
 * Expose the required game states using this module.
 */

'use strict';

exports.Boot = require('./Boot');
exports.Preloader = require('./Preloader');
exports.MainMenu = require('./MainMenu');
exports.Game = require('./Game');
exports.Battleground = require('./Battleground');
exports.GameOver = require('./GameOver');
exports.Credits = require('./Credits');
},{"./Battleground":22,"./Boot":23,"./Credits":24,"./Game":25,"./GameOver":26,"./MainMenu":27,"./Preloader":28}],30:[function(require,module,exports){
/*
 * Custom Actions
 * ===================
 *
 * Stores code for custom actions to be taken during conversations.
 */

'use strict';

module.exports = CustomActions;

function CustomActions(game/*, ...args*/) {
  Phaser.Group.call(this, game/*, ...args*/);
  this._game = game;
}

CustomActions.prototype = Object.create(Phaser.Group.prototype);
CustomActions.prototype.constructor = CustomActions;

CustomActions.prototype.customAction = function(action) {
  if (action.startsWith('fadeInAndOut')) {
    this.fadeInAndOut(parseInt(action.substring('fadeInAndOut'.length)));
  } else if (action === 'startConv:prologue02') {
    this._game.camera.fade('#000000', 2000);
    this._game.camera.onFadeComplete.addOnce(function() {
      this._game.camera.flash('#000000', 2000);
      this.startConversation('prologue02');
    }, this);
  } else if (action.startsWith('moveToArea:')) {
    this.moveToArea(action.substring('moveToArea:'.length));
  } else if (action === 'startBattle') {
    this.loadBattle();  
  } else if (action === 'loadMainGameState') {
    this._game.state.start('Game', true, false, this._game, false, true);
  } else if (action.startsWith('gameover')) {
    this._game.state.start('GameOver', true, false, this._game, action.substring('gameover'.length));
  } else if (action === 'credits') {
    this._game.state.start('Credits', true, false, this._game);
  }
};




CustomActions.prototype.loadBattle = function() {
  this._game.dialogueWindow.hide();
  this._game.state.start('Battleground', true, false);
};

CustomActions.prototype.startConversation = function(conv) {
  this._game.dialogueWindow.begin(conv);
};

CustomActions.prototype.moveToArea = function(area) {
  this._game.room.loadArea(area);
};

CustomActions.prototype.fadeInAndOut = function(duration) {
  this._game.camera.fade('#000000', duration/2);
  this._game.dialogueWindow.avatar.visible = false;
  this._game.dialogueWindow.dialogPanel.visible = false;
  this._game.camera.onFadeComplete.addOnce(function() {
    this._game.camera.flash('#000000', duration/2);
    this._game.dialogueWindow.avatar.visible = true;
    this._game.dialogueWindow.dialogPanel.visible = true;
  }, this);
};
},{}],31:[function(require,module,exports){
module.exports={
	"shuttle": {
		"id": "shuttle",
		"name": "Shuttle",
		"bg": "shuttle",
		"music": "puzzle2",
		"items": [
			{
				"id": "listener",
				"x": 150,
				"y": 150,
				"height": 100,
				"width": 100
			}, {
				"id": "note",
				"x": 720,
				"y": 200,
				"height": 100,
				"width": 100
			}
		],
		"placeables": [],
		"npcs": [],
		"navigable": false,
		"areaAccess": []
	},
	"hangar": {
		"id": "hangar",
		"name": "Hangar Bay",
		"bg": "hangar",
		"music": "lostjungle",
		"items": [],
		"placeables": [
			{
				"id": "shuttle-placeable",
				"x": 475,
				"y": 300,
				"height": 300,
				"width": 401
			}
		],
		"npcs": [
			{
				"id": "Vesper",
				"x": 100,
				"y": 350,
				"height": 350,
				"width": 150
			}, {
				"id": "Gleaming Shoal",
				"x": 400,
				"y": 300,
				"height": 400,
				"width": 400,
				"showif": {
					"xenopsychologist": "done",
					"xenobiologist": "done"
				}
			}
		],
		"navigable": true,
		"areaAccess": ["medbay"]
	},
	"medbay": {
		"id": "medbay",
		"name": "Medical Bay",
		"bg": "medbay",
		"music": "puzzle1",
		"items": [],
		"placeables": [],
		"npcs": [
			{
				"id": "Dr. Talvine Mesmer-Quiverly",
				"x": 320,
				"y": 340,
				"height": 183,
				"width": 100
			}, {
				"id": "Dr. Valken",
				"x": 600,
				"y": 250,
				"height": 330,
				"width": 112.5
			}
		],
		"navigable": true,
		"areaAccess": ["hangar"]
	}
}

},{}],32:[function(require,module,exports){
module.exports={
	"listener": {
		"id": "listener",
		"url": "listener.png",
		"name": "Listener",
		"desc": "A small, pocket-sized blue orb that is normally cool to the touch, but warms when your mysterious rescuer uses it to communicate with you. He/she told you to keep this safe, and let no one know of its true purpose."
	},
	"note": {
		"id": "note",
		"url": "note.png",
		"name": "Indecipherable Note",
		"desc": "A note covered in strange alien symbols. Your mysterious rescuer left this for you, saying it would help explain things, but so far you can't understand it."
	},
	"shuttle-placeable": {
		"id": "shuttle-placeable",
		"url": "shuttle-placeable.png",
		"name": "My Shuttle",
		"message": "That's my shuttle, but I can't go in there right now."
	},
	"biologistApproval": {
		"id": "biologistApproval",
		"url": "talvine.png",
		"name": "Dr. Talvine's Report",
		"desc": "A clean bill of health from Dr. Talvine Mesmer-Quiverly, Station Zero's xenobiologist."
	},
	"psychologistApproval": {
		"id": "psychologistApproval",
		"url": "valken.png",
		"name": "Dr. Valken's Report",
		"desc": "A briefing on your psychological state from Dr. Valken, Station Zero's xenopsychologist."
	},
	"secretaryNote": {
		"id": "secretaryNote",
		"url": "secretaryNote.png",
		"name": "Memo to Garnetta",
		"desc": "\"Garnetta: keep talking with Clearance staff. You won't be interrupted.\""
	}
}
},{}],33:[function(require,module,exports){
module.exports={
	"Mysterious Voice": {
		"id": "Mysterious Voice",
		"name": "Mysterious Voice",
		"image": "mysterious-voice",
		"avatar": "mysterious-voice",
	},
	"Gleaming Shoal": {
		"id": "Gleaming Shoal",
		"name": "Gleaming Shoal",
		"image": "gleaming-shoal-npc",
		"avatar": "gleaming-shoal",
		"conv": "gleaming-shoal01"
	},
	"Unknown Alien": {
		"id": "Gleaming Shoal",
		"name": "Unknown Alien",
		"image": "unknown-alien",
		"avatar": "unknown-alien"
	},
	"Kismet": {
		"id": "Kismet",
		"name": "Kismet",
		"image": "kismet",
		"avatar": "kismet"
	},
	"Vesper": {
		"id": "Vesper",
		"name": "Vesper",
		"image": "vesper-npc",
		"avatar": "vesper",
		"conv": "vesper01"
	},
	"Dr. Talvine Mesmer-Quiverly": {
		"id": "Dr. Talvine Mesmer-Quiverly",
		"name": "Dr. Talvine",
		"image": "talvine-npc",
		"avatar": "talvine",
		"conv": "talvine01"
	},
	"Dr. Valken": {
		"id": "Dr. Valken",
		"name": "Dr. Valken",
		"image": "valken-npc",
		"avatar": "valken",
		"conv": "valken01"
	}
}
},{}],34:[function(require,module,exports){
module.exports={
	"call-bluff": {
		"id": "call-bluff",
		"url": "call-bluff.png",
		"name": "Call Bluff",
		"desc": "Your adversary is willing to make some bold claims to win this argument. Call out their unsubstantiated bluffs for what they are."
	}
}
},{}],35:[function(require,module,exports){
module.exports={
	"speaker": {
		"font": "20px Goudy Bookletter 1911", 
		"fill": "#48f2ff", 
		"wordWrap": false, 
		"align": "left"
	},
	"dialogueBody": {
		"font": "14px Open Sans", 
		"fill": "#48f2ff", 
		"wordWrap": true, 
		//"wordWrapWidth": "this._dialogTextWidth",
		"align": "left"
	},
	"choiceButton": {
		"font": "14px Open Sans",
		"fill": "#48f2ff", 
		"wordWrap": true,
		//"wordWrapWidth": this._dialogTextWidth - buttonSidePadding, 
		"align": "left"
	},
	"toast": {
		"font": "14px Open Sans",
		"fill": "#48f2ff",
		"boundsAlignH": "center"
	},
	"credibility": {
		"font": "32px Cinzel Decorative", 
		"fontWeight": "bold",
		"fill": "#48f2ff", 
		"boundsAlignH": "center", 
		"boundsAlignV": "middle"
	},
	"mainMenuTitle": {
		"font": "75px Cinzel Decorative",
		"fontWeight": "bold",
		"fill": "#42dff4",
		"align": "center"
	}, 
}
},{}]},{},[1])(1)
});

//# sourceMappingURL=game.min.js.map
